import xml.etree.ElementTree as ET
import re
import asyncio
import aio_pika
import base64
import json
from distance import Find_materials
from datetime import datetime
from functools import partial
from hash2text import text_from_hash
from split_by_keys import Key_words
import config as conf
# from config import connection_url, first_queue, second_queue

class Order_recognition():

    def __init__(self):
        self.find_mats = Find_materials()


    def write_logs(self, text, event=1):
        event = 'EVENT' if event == 1 else 'ERROR'
        date_time = datetime.now().astimezone()
        file_name = './logs/' + str(date_time.date()) + '.txt'
        log = open(file_name, 'a')
        log.write(str(date_time) + ' | ' + event + ' | ' + text + '\n')
        log.close()

    def consumer_test(self, hash:str=None, content:str=None):
        if content is None:
            content = text_from_hash(hash)
            print('Text - ', content, flush=True)
        kw = Key_words()
        clear_email = kw.find_key_words(content)
        # Отправляем распознаннaй текст(!) на поиск материалов
        print('Очищенное сообщение -', clear_email)
        results = str(self.find_mats.find_mats(clear_email))
        self.write_logs('results - ' + results, 1)
        print('results = ', results)
        # self.send_result(results)

    async def save_truth(self,
            msg: aio_pika.IncomingMessage):
        # используем контекстный менеджер для ack'а сообщения
        async with msg.process():
            content = msg.body
            if 'true_value' not in str(content):
                return
            self.write_logs('Получилось взять ответы МЕТОД 2', 1)
            print('Получилось взять ответы МЕТОД 2', flush=True)
            body = json.loads(content)
            print("METHOD 2 - ", body, flush=True)
            self.write_logs('METHOD 2 - ' + str(body), 1)
            req_Number = body['req_number']
            if req_Number in self.find_mats.saves.index:
                positions = json.loads(self.find_mats.saves.loc[req_Number]['positions'].replace("'", '"'))['positions']
                true_positions = body['positions']
                for ind, pos in enumerate(true_positions):
                    request_text = positions[int(pos['position_id'])]['request_text']
                    true_mat = self.find_mats.all_materials[self.find_mats.all_materials['Материал'].\
                            str.contains(str(int(pos['true_material'])))]['Полное наименование материала'].values[0]
                    if 'spec_mat' in pos.keys():
                        this_client_only = True if pos['spec_mat'] == 'X' else False
                    else:
                        this_client_only = False
                    res = str({'num_mat':str(int(pos['true_material'])),
                                'name_mat':true_mat,
                                'true_ei':pos['true_ei'],
                                'true_value':pos['true_value'],
                                'spec_mat':str(this_client_only)})
                    res = base64.b64encode(bytes(res, 'utf-8'))
                    self.find_mats.method2.loc[request_text] = res.decode('utf-8')
                self.find_mats.method2.to_csv('data/method2.csv')
            else:
                print('Не нашёл такого письма', flush=True)
    async def consumer(self,
            msg: aio_pika.IncomingMessage,
            channel: aio_pika.RobustChannel,
    ):
        # используем контекстный менеджер для ack'а сообщения
        async with msg.process():
            print('Что-то получил из очереди rebbitmq...', flush=True)
            content = msg.body
            if 'true_value' in str(content):
                return
            self.write_logs('Получилось взять письмо из очереди', 1)
            print('Получилось взять письмо из очереди', flush=True)
            body = json.loads(content)
            self.write_logs('Body - ' + str(body), 1)
            content = text_from_hash(body['email'])
            # print('Text - ', content)
            kw = Key_words()
            clear_email = kw.find_key_words(content)
            # Отправляем распознанный текст(!) на поиск материалов
            print('Clear email - ', clear_email)
            results = str(self.find_mats.find_mats(clear_email))
            self.write_logs('results - ' + results, 1)
            print('results = ', results)
            # self.send_result(results)

            # проверяем, требует ли сообщение ответа
            if msg.reply_to:
                # отправляем ответ в default exchange
                print('Отправляем результат', flush=True)
                self.write_logs('Отправляем результaт', 1)
                await channel.default_exchange.publish(
                    message=aio_pika.Message(
                        content_type='application/json',
                        body=str.encode(results.replace("'", '"')[1:-1]),
                        # body=b'{"a":"b"}',
                        correlation_id=msg.correlation_id
                    ),
                    routing_key=msg.reply_to,  # самое важное

                )
    def get_message(self, body):
        body = json.loads(body)
        print(body)

        try:
            content = base64.standard_b64decode(base64.standard_b64decode(body['email']))\
                .decode('utf-8')
            root = ET.fromstring(content)
            content = root[0][0][2].text
            content = re.sub(r'\<.*?\>', '', content).replace('&nbsp;', '')
        except Exception as exc:
            self.write_logs('Письмо не читается,'+str(exc), 0)
            print('Error, письмо не читается,', exc)
            return 'Error while reading'
        return content

    async def main(self):
        connection = await aio_pika.connect_robust(
            conf.connection_url
        )


        async with connection:
            channel = await connection.channel()
            queue = await channel.declare_queue(conf.first_queue)
            # через partial прокидываем в наш обработчик сам канал
            await queue.consume(partial(self.consumer, channel=channel))
            print('Слушаем очередь', flush=True)


            queue2 = await channel.declare_queue(conf.second_queue)
            await queue2.bind(exchange=conf.exchange, routing_key=conf.routing_key)
            # через partial прокидываем в наш обработчик сам канал
            await queue2.consume(partial(self.save_truth))
            print('Слушаем очередь2', flush=True)
            try:
                await asyncio.Future()
            except Exception:
                pass

    def start(self):
        asyncio.run(self.main())

if __name__ == '__main__':
    order_rec = Order_recognition()
    order_rec.start()
    # order_rec.consumer_test(hash='UEQ5NGJXd2dkbVZ5YzJsdmJqMG5NUzR3SnlCbGJtTnZaR2x1WnowbmRYUm1MVGduUHo0OGMyOWhjR1Z1ZGpwRmJuWmxiRzl3WlNCNGJXeHVjenB6YjJGd1pXNTJQU0pvZEhSd09pOHZjMk5vWlcxaGN5NTRiV3h6YjJGd0xtOXlaeTl6YjJGd0wyVnVkbVZzYjNCbEx5SStQSE52WVhCbGJuWTZRbTlrZVQ0OGFuTnZiazlpYW1WamRENDhiMkpxWldOMFRtRnRaVDV0YzJkZlpUWmlNekpoTkRKaU1EaG1NR014TUdJMk9XSXhOV1l6T0ROak5UZzBNVEk4TDI5aWFtVmpkRTVoYldVK1BHSjFZMnRsZEU1aGJXVStZM0p0TFdWdFlXbHNQQzlpZFdOclpYUk9ZVzFsUGp4bWFXeGxRMjl1ZEdWdWRENG1iSFE3YUhSdGJENG1JM2hrT3dvbWJIUTdhR1ZoWkQ0bUkzaGtPd29tYkhRN2JXVjBZU0JvZEhSd0xXVnhkV2wyUFNKRGIyNTBaVzUwTFZSNWNHVWlJR052Ym5SbGJuUTlJblJsZUhRdmFIUnRiRHNnWTJoaGNuTmxkRDExZEdZdE9DSStKaU40WkRzS0pteDBPeTlvWldGa1BpWWplR1E3Q2lac2REdGliMlI1UGlZamVHUTdDaVpzZER0d0lITjBlV3hsUFNKbWIyNTBMWE5wZW1VNk1UQndkRHNnWTI5c2IzSTZJekF3TURCbVppSStKbXgwTzJrKzBKTFFuZENWMEtqUW5kQ3YwSzhnMEovUW50Q24wS0xRa0RvZzBKWFJnZEM3MExnZzBMN1JndEMvMFlEUXNOQ3kwTGpSZ3RDMTBMdlJqQ0RRdmRDMTBMalF0OUN5MExYUmdkR0MwTFhRdlN3ZzBMM1F0U0RRdjlDMTBZRFF0ZEdGMEw3UXROQzQwWUxRdFNEUXY5QytJTkdCMFlIUmk5QzcwTHJRc05DOExDRFF2ZEMxSU5DKzBZTFF2OUdBMExEUXN0QzcwWS9RdWRHQzBMVWcwTC9Rc05HQTBMN1F1OUM0TENEUmdTRFF2dEdCMFlMUXZ0R0EwTDdRdHRDOTBMN1JnZEdDMFl6UmppRFF2dEdDMExyUmdOR0wwTExRc05DNTBZTFF0U0RRc3RDNzBMN1F0dEMxMEwzUXVOR1BMaVpzZERzdmFUNG1iSFE3TDNBK0ppTjRaRHNLSm14ME8ySnlQaVlqZUdRN0NpWnNkRHRpY2o0bUkzaGtPd29tYkhRN1luSStKaU40WkRzS0pteDBPMkp5UGlZamVHUTdDaVpzZER0a2FYWStKaU40WkRzS0pteDBPMlJwZGlCaGJHbG5iajBpYkdWbWRDSStKaU40WkRzS0pteDBPMlJwZGlCemRIbHNaVDBpYkdsdVpTMW9aV2xuYUhRNklESTBjSGc3SWo3UWw5QzAwWURRc05DeTBZSFJndEN5MFlQUXVkR0MwTFV1SUNac2REdGljajRtSTNoa093clFuOUdBMEw3UmlOR0RJTkN5MFl2UmdkR0MwTERRc3RDNDBZTFJqQ0RSZ2RHSDBMWFJnaURRdmRDd0lOQzMwTERSajlDeTBMclJneUFtYkhRN1lTQnpkSGxzWlQwaVkyOXNiM0k2SUNNek16TTdJSFJsZUhRdFpHVmpiM0poZEdsdmJqb2dibTl1WlRzaVBsdGplVzUwWld0aElHbGtJRFF4TVRjMU9TWnNkRHN2WVQ1ZElPS0FreVlqZUdRN0NpWnNkRHRoSUhOMGVXeGxQU0pqYjJ4dmNqb2dJelJoT1RCbE1qc2dkR1Y0ZEMxa1pXTnZjbUYwYVc5dU9pQjFibVJsY214cGJtVTdJaUJvY21WbVBTSm9kSFJ3Y3pvdkwzQnliMlJoZG1GNUxuTmxiQzFpWlM1eWRTOWpiM0psTDI5eVpHVnljeTh5T0RVNU9EVTRPUzlrYjNkdWJHOWhaQzlzYVcxcGRHVmtQMmxrUFRJNE5UazROVGc1Sm1GdGNEdGhiWEE3Y21WeGRXVnpkRWxrUFRVeE56WTNNVFU1TUNaaGJYQTdZVzF3TzJOdlpHVTlaRGhsTnpRd1lUVmhaV1pqTTJJME5tVTJNakUxWkRka05ESmlNVEV3WVdJaVBpWWplR1E3Q3RHQjBMclFzTkdIMExEUmd0R01JTkMzMExEUmo5Q3kwTHJSZ3lac2REc3ZZVDRzSUNac2REdGhJSE4wZVd4bFBTSmpiMnh2Y2pvZ0l6TXpNenNnZEdWNGRDMWtaV052Y21GMGFXOXVPaUJ1YjI1bE95SSswSkRRbmlBbVlXMXdPM0YxYjNRNzBLUFFuOUNpMEpvdDBLM1FvdENRMEp2UW50Q2RKbUZ0Y0R0eGRXOTBPeVpzZERzdllUNHNJTkdBMExYUXV0Q3kwTGpRdDlDNDBZTFJpeURpZ0pNbUkzaGtPd29tYkhRN1lTQnpkSGxzWlQwaVkyOXNiM0k2SUNNMFlUa3daVEk3SUhSbGVIUXRaR1ZqYjNKaGRHbHZiam9nZFc1a1pYSnNhVzVsT3lJZ2FISmxaajBpYUhSMGNITTZMeTl3Y205a1lYWmhlUzV6Wld3dFltVXVjblV2WTI5eVpTOXpkWEJ3YkdsbGNpOWpiMjF3WVc1NUx6TTBPRGc1TDNKbGNYVnBjMmwwWlhNdmJHbHRhWFJsWkQ5cFpEMHlPRFU1T0RVNE9TWmhiWEE3WVcxd08zSmxjWFZsYzNSSlpEMDFNVGMyTnpFMU9UQW1ZVzF3TzJGdGNEdGpiMlJsUFdRNFpUYzBNR0UxWVdWbVl6TmlORFpsTmpJeE5XUTNaRFF5WWpFeE1HRmlJajRtSTNoa093clJnZEM2MExEUmg5Q3cwWUxSakNac2REc3ZZVDR1SUNac2REdGljajRtSTNoa093clFsTkM3MFk4ZzBMN1JndEMvMFlEUXNOQ3kwTHJRdUNEUmdkR0gwTFhSZ3RDd0lOQzkwTERRdHRDODBMalJndEMxSUNac2REdGhJSE4wZVd4bFBTSmpiMnh2Y2pvZ0kyWm1NREF4TXpzZ2RHVjRkQzFrWldOdmNtRjBhVzl1T2lCMWJtUmxjbXhwYm1VN0lpQm9jbVZtUFNKb2RIUndjem92TDNCeWIyUmhkbUY1TG5ObGJDMWlaUzV5ZFM5amIzSmxMM04xY0hCc2FXVnlMM0psWjJsemRISjVMMnhwYldsMFpXUS9hV1E5TWpnMU9UZzFPRGttWVcxd08yRnRjRHR5WlhGMVpYTjBTV1E5TlRFM05qY3hOVGt3Sm1GdGNEdGhiWEE3WTI5a1pUMWtPR1UzTkRCaE5XRmxabU16WWpRMlpUWXlNVFZrTjJRME1tSXhNVEJoWWlaaGJYQTdZVzF3TzJGamRHbHZiajF6Wlc1a0lqNG1JM2hrT3dyUWw5Q1UwSlhRb2RDc0pteDBPeTloUGk0Z0pteDBPeTlrYVhZK0ppTjRaRHNLSm14ME8ySnlQaVlqZUdRN0NpWnNkRHRrYVhZK01TNGcwSzNRdTlDMTBMclJndEdBMEw3UXRDRFF2OUdBMEw3UXM5R0EwTFhRc3RDKzBZZlF2ZEdMMExrZzBKTFFvRFFnVEQwekxqTWcwTHdnTFNBeExEVWcwWUlnS0VsRUlOQy8wTDdRdDlDNDBZYlF1TkM0SURrMU9EUXlOVFVwSUNac2REc3ZaR2wyUGlZamVHUTdDaVpzZER0aWNqNG1JM2hrT3dvbWJIUTdaR2wyUHRDVTBMN1F2OUMrMEx2UXZkQzQwWUxRdGRDNzBZelF2ZEN3MFk4ZzBMalF2ZEdFMEw3UmdOQzgwTERSaHRDNDBZODZJQ1pzZERzdlpHbDJQaVlqZUdRN0NpWnNkRHRrYVhZZ2MzUjViR1U5SW5SbGVIUXRZV3hwWjI0NklHeGxablE3SWo0eExpRFFuOUMrMFlIUmd0Q3cwTExRdU5HQzBZd2cwTG9nTVRndU1ETXVNakF5TkNBbWJIUTdMMlJwZGo0bUkzaGtPd29tYkhRN1pHbDJJSE4wZVd4bFBTSjBaWGgwTFdGc2FXZHVPaUJzWldaME95SStNaTRnMEtMUmdOQzEwTEhSZzlDMTBZTFJnZEdQSU5DMDBMN1JnZEdDMExEUXN0QzYwTEFnMEwvUXZpRFFzTkMwMFlEUXRkR0IwWU02SU5DUTBMVFJnTkMxMFlFZzBML1JnTkMrMExYUXV0R0MwTEFnTFNEUW9OQyswWUhSZ2RDNDBZOGdMQ0RRb2RDeTBMWFJnTkMwMEx2UXZ0Q3kwWUhRdXRDdzBZOGcwTDdRc2RDNzBMRFJnZEdDMFl3Z0xDRFFsZEM2MExEUmd0QzEwWURRdU5DOTBMSFJnOUdBMExNZ0xDRFFuOUMxMFlYUXZ0R0MwTGpRdmRHRzBMWFFzaUFzSURMUXNDQW8wSmJRbWlEUW9OQ3cwWVBSZ3RDd0lOQ2YwWURRdnRHQjBZelFzZEN3SU5DeUlOQyswWUxRczlHQTBZUFF0OUMrMFlmUXZkR0wwWVVnMExUUXZ0QzYwWVBRdk5DMTBMM1JndEN3MFlVZzBML1F1TkdCMExEUmd0R01JRG9nMEpQUmdOR0QwTGZRdnRDLzBMN1F1OUdEMFlmUXNOR0MwTFhRdTlHTU9pRFFrTkNlSUNaaGJYQTdjWFZ2ZER2UW5kQyswTExRc05HQzBMN1JnQ1poYlhBN2NYVnZkRHNnMEpqUW5kQ2RJRGM0TVRReE1UZ3pPVFlnMEovUXZ0QzYwWVBRdjlDdzBZTFF0ZEM3MFl3NklOQ1EwSjRnSm1GdGNEdHhkVzkwTzlDajBKL1FvdENhTGRDdDBLTFFrTkNiMEo3UW5TWmhiWEE3Y1hWdmREc21JM2hrT3dvZzBKTFFvTkNWMEp6UXJ5RFFvTkNRMEpIUW50Q2kwS3NnMEo3UWtkQ3EwSlhRbXRDaTBKQTZJTkdCSURndU1EQWcwTFRRdmlBeE55NHdNQ3dnMEw3UXNkQzEwTFFnMFlFZ01USXVNREFnMExUUXZpQXhNeTR3TUNEUW5kQ3dJTkMrMExIUml0QzEwTHJSZ3RDMUlOQy8wWURRdnRHSTBZTWcwTDdSZ2RHQzBMRFFzdEM0MFlMUmpDQXhJTkdOMExyUXQ5QzEwTHpRdjlDNzBZL1JnQ0RSZ2RHSDBMWFJnaTNSaE5DdzBMclJndEdEMFlEUml5d2dNaURSamRDNjBMZlF0ZEM4MEwvUXU5R1AwWURRc0NEUmd0QyswTExRc05HQTBMM1F2dEM1SU5DOTBMRFF1dEM3MExEUXROQzkwTDdRdVNBbzBLTFFudENnMEpNdE1USXBJTkM0MEx2UXVDQXlJTkdOMExyUXQ5QzEwTHpRdjlDNzBZL1JnTkN3SU5DajBKL1FsQ0FzSURJZzBZM1F1dEMzMExYUXZOQy8wTHZSajlHQTBMQWcwWUxSZ05DdzBMM1JnZEMvMEw3UmdOR0MwTDNRdnRDNUlOQ2YwS0RRbUNEUW45Q2UwS0hRb3RDUTBKTFFtdENWSU5DYzBKRFFvdENWMEtEUW1OQ1EwSnZRbnRDU0lOQ2QwSlhRbnRDUjBLWFFudENVMEpqUW5OQ2VJTkNmMEtEUWxkQ1UwSjdRb2RDaTBKRFFrdENZMEtMUXJDRFFvZENWMEtEUW90Q1kwS1RRbU5DYTBKRFFvdENySmlONFpEc0tJTkNZSU5DZjBKRFFvZENmMEo3UW9OQ2kwSkFoS1NBbWJIUTdMMlJwZGo0bUkzaGtPd29tYkhRN1pHbDJJSE4wZVd4bFBTSjBaWGgwTFdGc2FXZHVPaUJzWldaME95SStNeTRnMEtMUmdOQzEwTEhSZzlDMTBZTFJnZEdQSU5DKzBZTFJnZEdBMEw3Umg5QzYwTEFnMEwvUXU5Q3cwWUxRdGRDMjBMQXNJRE13MExUUXZkQzEwTGtnSm14ME95OWthWFkrSmlONFpEc0tKbXgwTzJKeVBpWWplR1E3Q3RDdDBMdlF0ZEM2MFlMUmdOQyswTFFnMEwvUmdOQyswTFBSZ05DMTBMTFF2dEdIMEwzUmk5QzVJTkNmMExYUmd0R0EwTDdRc2lEUW5OQ3cwTHJSZ2RDNDBMd2dPQzA1TWpFdE56Y3pMVEU0TFRBNElOQ1QwTFhRdlM0ZzBKL1F2dEMwMFlEUmo5QzAwWWZRdU5DNk9pRFFrTkNlSUNaaGJYQTdjWFZ2ZER2UW5kQyswTExRc05HQzBMN1JnQ1poYlhBN2NYVnZkRHNnTFNBak5ERXhOelU1SmlONFpEc0tKbXgwTzJKeVBpWWplR1E3Q2lac2REdGljajRtSTNoa093b21iSFE3WkdsMlB0Q1YwWUhRdTlDNElOQzkwTFhRdnRDeDBZWFF2dEMwMExqUXZOQytJTkMzMExEUXROQ3cwWUxSakNEUXN0QyswTC9SZ05DKzBZRWcwTC9RdmlEUXQ5Q3cwWS9Rc3RDNjBMVXNJTkM5MExEUXR0QzgwTGpSZ3RDMUlDWnNkRHRoSUhOMGVXeGxQU0pqYjJ4dmNqb2dJelJoT1RCbE1qc2dkR1Y0ZEMxa1pXTnZjbUYwYVc5dU9pQjFibVJsY214cGJtVTdJaUJvY21WbVBTSm9kSFJ3Y3pvdkwzQnliMlJoZG1GNUxuTmxiQzFpWlM1eWRTOWpiM0psTDNOMWNIQnNhV1Z5TDNKbFoybHpkSEo1TDJ4cGJXbDBaV1EvYVdROU1qZzFPVGcxT0RrbVlXMXdPMkZ0Y0R0eVpYRjFaWE4wU1dROU5URTNOamN4TlRrd0ptRnRjRHRoYlhBN1kyOWtaVDFrT0dVM05EQmhOV0ZsWm1NellqUTJaVFl5TVRWa04yUTBNbUl4TVRCaFlpWmhiWEE3WVcxd08yRmpkR2x2YmoxamFHRjBJajRtSTNoa093clFsOUNVMEpYUW9kQ3NKbXgwT3k5aFBpNGdKbXgwT3k5a2FYWStKaU40WkRzS0pteDBPMkp5UGlZamVHUTdDaVpzZER0a2FYWWdjM1I1YkdVOUltTnZiRzl5T2lCeVpXUWlQdENmMFlEUXVDRFF2OUMrMFlIUmd0Q3cwTExRdXRDMUlOQzgwTERSZ3RDMTBZRFF1TkN3MEx2UXZ0Q3lJTkN5SU5DaTBLTFFuU0RRdmRDMTBMN1FzZEdGMEw3UXROQzQwTHpRdmlEUmc5QzYwTERRdDlHTDBMTFFzTkdDMFl3ZzBMM1F2dEM4MExYUmdDRFF0OUN3MFkvUXN0QzYwTGdnUTNsdWRHVnJZU0RRdUNEUXZkQyswTHpRdGRHQUlOR0IwTDdRdjlHQTBMN1FzdEMrMExUUXVOR0MwTFhRdTlHTTBMM1F2dEN6MEw0ZzBLUFFuOUNVTGlEUWtpRFF2OUN3MExyUXRkR0MwTFVnMFlMUXZ0Q3kwTERSZ05DKzBZSFF2dEMvMFlEUXZ0Q3kwTDdRdE5DNDBZTFF0ZEM3MFl6UXZkR0wwWVVnMExUUXZ0QzYwWVBRdk5DMTBMM1JndEMrMExJZzBMN1FzZEdQMExmUXNOR0MwTFhRdTlHTTBMM1F2aURRdE5DKzBMdlF0dEMxMEwwZzBMSFJpOUdDMFl3ZzBMVFF2dEM2MFlQUXZOQzEwTDNSZ2lEUXU5R08wTEhRdnRDNUlOR0UwTDdSZ05DODBZc2cwWUVnMEwvUXZ0QzcwTDNSaTlDOElOQy8wTFhSZ05DMTBZZlF2ZEMxMEx3ZzBMelFzTkdDMExYUmdOQzQwTERRdTlDKzBMSWcwWUVnMFlQUXV0Q3cwTGZRc05DOTBMalF0ZEM4SU5DOTBMRFF1TkM4MExYUXZkQyswTExRc05DOTBMalJqeXdtSTNoa093b2cwTHJRdnRDNzBMalJoOUMxMFlIUmd0Q3kwTEFnMExnZzBMWFF0QzRnMExqUXQ5QzhMaURRdjlDK0lOQzYwTERRdHRDMDBMN1F1U0RRdjlDKzBMZlF1TkdHMExqUXVDNGdKbXgwT3k5a2FYWStKaU40WkRzS0pteDBPMkp5UGlZamVHUTdDaVpzZER0a2FYWStKbXgwTzJKeVBpWWplR1E3Q3RDaElOR0QwTExRc05DMjBMWFF2ZEM0MExYUXZDd2dKbXgwTzJKeVBpWWplR1E3Q3RDUTBKNGdKbUZ0Y0R0eGRXOTBPOUNqMEovUW90Q2FMZEN0MEtMUWtOQ2IwSjdRblNaaGJYQTdjWFZ2ZERzZ0pteDBPMkp5UGlZamVHUTdDdENiMFlQUXZkQzEwTExRc0NEUWxkQzcwTFhRdmRDd0lOQ2cwTERSaE5DdzBMalF1OUMrMExMUXZkQ3dJQ1pzZER0aWNqNG1JM2hrT3dwbGJHVnVZUzVwZFc1bGRtRkFaWFJoYkc5dVozSnZkWEF1WTI5dElDWnNkRHRpY2o0bUkzaGtPd3B1ZFd4c0lDWnNkRHRpY2o0bUkzaGtPd29tYkhRN0wyUnBkajRtSTNoa093b21iSFE3TDJScGRqNG1JM2hrT3dvbWJIUTdhVzFuSUhkcFpIUm9QU0l3SWlCb1pXbG5hSFE5SWpBaUlITjBlV3hsUFNKM2FXUjBhRG93Y0hnZ0lXbHRjRzl5ZEdGdWREc2dhR1ZwWjJoME9qQndlQ0FoYVcxd2IzSjBZVzUwT3lJZ2MzSmpQU0pvZEhSd2N6b3ZMMmwwWVdSdGFXNXpZM2x1ZEdWcllYSjFMbVJ0WlhOd0xuSjFMMjl3Wlc1bFpDNXdhSEEvYlQwNE9EZG1NR0ZsWldZek16RXdZbUUwTkRrMVpXTTJaalJqTURWaVl6TTVNaVpoYlhBN1lXMXdPMk05TVNaaGJYQTdZVzF3TzJOcFpEMHdKbUZ0Y0R0aGJYQTdkVDB4TWpjMk9Ua21ZVzF3TzJGdGNEdHpQVGs0TWpNbVlXMXdPMkZ0Y0R0bFBXSXpTbk5pTTFwb1dsaGFRV016UW5KTWJrb3hKbUZ0Y0R0aGJYQTdjajFEZEVOWU1FeEVVWFk1UjBFd1REZFNaMU5FVVhZNVF5NUpUa016TUV4RVVtbzVRM2t3VEhKUmRGTkJiMWt6YkhWa1IxWnlXVk5DY0ZwRFFXZE9SRVY0VG5wVk5VdFJiMmRKUTBGblNVTkJaMGxEUVdjd1REZFNaMmxFVVcwNVIwUXdURE5SZEdSRGVUQk1RV2N3U2xWMVNVNURaMHhwUVdkSlRrTTBNRXhqWnpCS1JGRnVhVUZwTUV0UVVXNDVRMmt3U205ME1Fc3pVVzkwUTFFd1NuWlJiblJEWkVscFFXZERhVUZuU1VOQlowbERRV2REYVVGblNVTkJaMGxEUVdkSlEzZG5TMGh3YUdFelZuZFpXR3RuWVZkUlowMXFaekZQVkdjeFQwUnJjRU5wUVdkSlEwRm5TVU5CWjBsRFJGRjJPVU11U1U1RE16Qk1SRkYyT1VkQk1FdzNVbWRrUjBSSlJuTXhUVlJqTWs1NlJURlBWRUprSm1GdGNEdGhiWEE3ZGowaUlHRnNkRDBpSWo0bUkzaGtPd29tYkhRN0wyUnBkajRtSTNoa093b21iSFE3TDJKdlpIaytKaU40WkRzS0pteDBPeTlvZEcxc1BpWWplR1E3Q2p3dlptbHNaVU52Ym5SbGJuUStQQzlxYzI5dVQySnFaV04wUGp3dmMyOWhjR1Z1ZGpwQ2IyUjVQand2YzI5aGNHVnVkanBGYm5abGJHOXdaVDQ9')
    # order_rec.consumer_test(hash='UEQ5NGJXd2dkbVZ5YzJsdmJqMG5NUzR3SnlCbGJtTnZaR2x1WnowbmRYUm1MVGduUHo0OGMyOWhjR1Z1ZGpwRmJuWmxiRzl3WlNCNGJXeHVjenB6YjJGd1pXNTJQU0pvZEhSd09pOHZjMk5vWlcxaGN5NTRiV3h6YjJGd0xtOXlaeTl6YjJGd0wyVnVkbVZzYjNCbEx5SStQSE52WVhCbGJuWTZRbTlrZVQ0OGFuTnZiazlpYW1WamRENDhiMkpxWldOMFRtRnRaVDV0YzJkZk56TmxNVFF6TW1Wa01tRXdZbVZsTTJNMFl6WXpaakF6WWpFM1lXRXhNMk04TDI5aWFtVmpkRTVoYldVK1BHSjFZMnRsZEU1aGJXVStZM0p0TFdWdFlXbHNQQzlpZFdOclpYUk9ZVzFsUGp4bWFXeGxRMjl1ZEdWdWRENG1iSFE3YUhSdGJENG1JM2hrT3dvbWJIUTdhR1ZoWkQ0bUkzaGtPd29tYkhRN2JXVjBZU0JvZEhSd0xXVnhkV2wyUFNKRGIyNTBaVzUwTFZSNWNHVWlJR052Ym5SbGJuUTlJblJsZUhRdmFIUnRiRHNnWTJoaGNuTmxkRDExZEdZdE9DSStKaU40WkRzS0pteDBPeTlvWldGa1BpWWplR1E3Q2lac2REdGliMlI1UGlZamVHUTdDaVpzZER0d0lITjBlV3hsUFNKbWIyNTBMWE5wZW1VNk1UQndkRHNnWTI5c2IzSTZJekF3TURCbVppSStKbXgwTzJrKzBKTFFuZENWMEtqUW5kQ3YwSzhnMEovUW50Q24wS0xRa0RvZzBKWFJnZEM3MExnZzBMN1JndEMvMFlEUXNOQ3kwTGpSZ3RDMTBMdlJqQ0RRdmRDMTBMalF0OUN5MExYUmdkR0MwTFhRdlN3ZzBMM1F0U0RRdjlDMTBZRFF0ZEdGMEw3UXROQzQwWUxRdFNEUXY5QytJTkdCMFlIUmk5QzcwTHJRc05DOExDRFF2ZEMxSU5DKzBZTFF2OUdBMExEUXN0QzcwWS9RdWRHQzBMVWcwTC9Rc05HQTBMN1F1OUM0TENEUmdTRFF2dEdCMFlMUXZ0R0EwTDdRdHRDOTBMN1JnZEdDMFl6UmppRFF2dEdDMExyUmdOR0wwTExRc05DNTBZTFF0U0RRc3RDNzBMN1F0dEMxMEwzUXVOR1BMaVpzZERzdmFUNG1iSFE3TDNBK0ppTjRaRHNLSm14ME8ySnlQaVlqZUdRN0NpWnNkRHRpY2o0bUkzaGtPd29tYkhRN1luSStKaU40WkRzS0pteDBPMkp5UGlZamVHUTdDaVpzZER0a2FYWStKaU40WkRzS0pteDBPMlJwZGlCemRIbHNaVDBpWm05dWRDMW1ZVzFwYkhrNklHRnlhV0ZzTENCb1pXeDJaWFJwWTJFc0lITmhibk10YzJWeWFXWTdJR1p2Ym5RdGMybDZaVG9nTVRKd2REc2dZMjlzYjNJNklDTXdNREF3TURBaVBpWWplR1E3Q2lac2REdGthWFkrMEpUUXZ0Q3gwWURRdnRDMUlOR0QwWUxSZ05DK0lTRWhJU0VtWVcxd08yNWljM0E3SU5DbTBMWFF2ZEN3Sm1GdGNEdHVZbk53T3lEUXVDRFF2ZEN3MEx2UXVOR0gwTGpRdFRvbWJIUTdMMlJwZGo0bUkzaGtPd29tYkhRN1pHbDJQaVpzZER0aWNpQmtZWFJoTFcxalpTMWliMmQxY3owaU1TSStKaU40WkRzS0pteDBPeTlrYVhZK0ppTjRaRHNLSm14ME8yUnBkajRtYkhRN0lTMHRVM1JoY25SR2NtRm5iV1Z1ZEMwdFBpWWplR1E3Q2lac2REdGthWFlnYzNSNWJHVTlJbU52Ykc5eU9pQWpNREF3TURBd095Qm1iMjUwTFdaaGJXbHNlVG9nWVhKcFlXd3NJR2hsYkhabGRHbGpZU3dnYzJGdWN5MXpaWEpwWmpzZ1ptOXVkQzF6YVhwbE9pQXhNbkIwT3lCbWIyNTBMWE4wZVd4bE9pQnViM0p0WVd3N0lHWnZiblF0ZG1GeWFXRnVkQzFzYVdkaGRIVnlaWE02SUc1dmNtMWhiRHNnWm05dWRDMTJZWEpwWVc1MExXTmhjSE02SUc1dmNtMWhiRHNnWm05dWRDMTNaV2xuYUhRNklEUXdNRHNnYkdWMGRHVnlMWE53WVdOcGJtYzZJRzV2Y20xaGJEc2diM0p3YUdGdWN6b2dNanNnZEdWNGRDMWhiR2xuYmpvZ2MzUmhjblE3SUhSbGVIUXRhVzVrWlc1ME9pQXdjSGc3SUhSbGVIUXRkSEpoYm5ObWIzSnRPaUJ1YjI1bE95QjNhV1J2ZDNNNklESTdJSGR2Y21RdGMzQmhZMmx1WnpvZ01IQjRPeUF0ZDJWaWEybDBMWFJsZUhRdGMzUnliMnRsTFhkcFpIUm9PaUF3Y0hnN0lIZG9hWFJsTFhOd1lXTmxPaUJ1YjNKdFlXdzdJR0poWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWkdaa1ptUTdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMTBhR2xqYTI1bGMzTTZJR2x1YVhScFlXdzdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMXpkSGxzWlRvZ2FXNXBkR2xoYkRzZ2RHVjRkQzFrWldOdmNtRjBhVzl1TFdOdmJHOXlPaUJwYm1sMGFXRnNPeUlnWkdGMFlTMXRZMlV0YzNSNWJHVTlJbU52Ykc5eU9pQWpNREF3TURBd095Qm1iMjUwTFdaaGJXbHNlVG9nWVhKcFlXd3NJR2hsYkhabGRHbGpZU3dnYzJGdWN5MXpaWEpwWmpzZ1ptOXVkQzF6YVhwbE9pQXhNbkIwT3lCbWIyNTBMWE4wZVd4bE9pQnViM0p0WVd3N0lHWnZiblF0ZG1GeWFXRnVkQzFzYVdkaGRIVnlaWE02SUc1dmNtMWhiRHNnWm05dWRDMTJZWEpwWVc1MExXTmhjSE02SUc1dmNtMWhiRHNnWm05dWRDMTNaV2xuYUhRNklEUXdNRHNnYkdWMGRHVnlMWE53WVdOcGJtYzZJRzV2Y20xaGJEc2diM0p3YUdGdWN6b2dNanNnZEdWNGRDMWhiR2xuYmpvZ2MzUmhjblE3SUhSbGVIUXRhVzVrWlc1ME9pQXdjSGc3SUhSbGVIUXRkSEpoYm5ObWIzSnRPaUJ1YjI1bE95QjNhV1J2ZDNNNklESTdJSGR2Y21RdGMzQmhZMmx1WnpvZ01IQjRPeUF0ZDJWaWEybDBMWFJsZUhRdGMzUnliMnRsTFhkcFpIUm9PaUF3Y0hnN0lIZG9hWFJsTFhOd1lXTmxPaUJ1YjNKdFlXdzdJR0poWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWkdaa1ptUTdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMTBhR2xqYTI1bGMzTTZJR2x1YVhScFlXdzdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMXpkSGxzWlRvZ2FXNXBkR2xoYkRzZ2RHVjRkQzFrWldOdmNtRjBhVzl1TFdOdmJHOXlPaUJwYm1sMGFXRnNPeUkrSmlONFpEc0tKbXgwTzJScGRqN1FrTkdBMEx6UXNOR0MwWVBSZ05Dd0lOR0VNVFlnMEpBMU1ERFFvU0F4TXRDOEptRnRjRHR1WW5Od095QXRJREV5TERnMk5OR0MwTDBtYkhRN0wyUnBkajRtSTNoa093b21iSFE3WkdsMlBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjam9nSXpBd01EQXdNRHNnWm05dWRDMW1ZVzFwYkhrNklHRnlhV0ZzTENCb1pXeDJaWFJwWTJFc0lITmhibk10YzJWeWFXWTdJR1p2Ym5RdGMybDZaVG9nTVRad2VEc2dabTl1ZEMxemRIbHNaVG9nYm05eWJXRnNPeUJtYjI1MExYZGxhV2RvZERvZ05EQXdPeUJzWlhSMFpYSXRjM0JoWTJsdVp6b2dibTl5YldGc095QjBaWGgwTFdsdVpHVnVkRG9nTUhCNE95QjBaWGgwTFhSeVlXNXpabTl5YlRvZ2JtOXVaVHNnZDI5eVpDMXpjR0ZqYVc1bk9pQXdjSGc3SUhkb2FYUmxMWE53WVdObE9pQnViM0p0WVd3N0lHSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVptWm1ZN0lHWnNiMkYwT2lCdWIyNWxPeUJrYVhOd2JHRjVPaUJwYm14cGJtVWdJV2x0Y0c5eWRHRnVkRHNpSUdSaGRHRXRiV05sTFhOMGVXeGxQU0pqYjJ4dmNqb2dJekF3TURBd01Ec2dabTl1ZEMxbVlXMXBiSGs2SUdGeWFXRnNMQ0JvWld4MlpYUnBZMkVzSUhOaGJuTXRjMlZ5YVdZN0lHWnZiblF0YzJsNlpUb2dNVFp3ZURzZ1ptOXVkQzF6ZEhsc1pUb2dibTl5YldGc095Qm1iMjUwTFhkbGFXZG9kRG9nTkRBd095QnNaWFIwWlhJdGMzQmhZMmx1WnpvZ2JtOXliV0ZzT3lCMFpYaDBMV2x1WkdWdWREb2dNSEI0T3lCMFpYaDBMWFJ5WVc1elptOXliVG9nYm05dVpUc2dkMjl5WkMxemNHRmphVzVuT2lBd2NIZzdJSGRvYVhSbExYTndZV05sT2lCdWIzSnRZV3c3SUdKaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWm1abVk3SUdac2IyRjBPaUJ1YjI1bE95QmthWE53YkdGNU9pQnBibXhwYm1VZ0lXbHRjRzl5ZEdGdWREc2lQdENRMFlEUXZOQ3cwWUxSZzlHQTBMQW1JM2hrT3dvZzBZUXhNaURRa0RVd01OQ2hJREV5MEx3bVlXMXdPMjVpYzNBN0lDMGdOU3d3T0RqUmd0QzlKbXgwT3k5emNHRnVQaVpzZER0aWNqNG1JM2hrT3dvbWJIUTdMMlJwZGo0bUkzaGtPd29tYkhRN1pHbDJQaVpzZER0emNHRnVJSE4wZVd4bFBTSmpiMnh2Y2pvZ0l6QXdNREF3TURzZ1ptOXVkQzFtWVcxcGJIazZJR0Z5YVdGc0xDQm9aV3gyWlhScFkyRXNJSE5oYm5NdGMyVnlhV1k3SUdadmJuUXRjMmw2WlRvZ01UWndlRHNnWm05dWRDMXpkSGxzWlRvZ2JtOXliV0ZzT3lCbWIyNTBMWGRsYVdkb2REb2dOREF3T3lCc1pYUjBaWEl0YzNCaFkybHVaem9nYm05eWJXRnNPeUIwWlhoMExXbHVaR1Z1ZERvZ01IQjRPeUIwWlhoMExYUnlZVzV6Wm05eWJUb2dibTl1WlRzZ2QyOXlaQzF6Y0dGamFXNW5PaUF3Y0hnN0lIZG9hWFJsTFhOd1lXTmxPaUJ1YjNKdFlXdzdJR0poWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1abVptWTdJR1pzYjJGME9pQnViMjVsT3lCa2FYTndiR0Y1T2lCcGJteHBibVVnSVdsdGNHOXlkR0Z1ZERzaUlHUmhkR0V0YldObExYTjBlV3hsUFNKamIyeHZjam9nSXpBd01EQXdNRHNnWm05dWRDMW1ZVzFwYkhrNklHRnlhV0ZzTENCb1pXeDJaWFJwWTJFc0lITmhibk10YzJWeWFXWTdJR1p2Ym5RdGMybDZaVG9nTVRad2VEc2dabTl1ZEMxemRIbHNaVG9nYm05eWJXRnNPeUJtYjI1MExYZGxhV2RvZERvZ05EQXdPeUJzWlhSMFpYSXRjM0JoWTJsdVp6b2dibTl5YldGc095QjBaWGgwTFdsdVpHVnVkRG9nTUhCNE95QjBaWGgwTFhSeVlXNXpabTl5YlRvZ2JtOXVaVHNnZDI5eVpDMXpjR0ZqYVc1bk9pQXdjSGc3SUhkb2FYUmxMWE53WVdObE9pQnViM0p0WVd3N0lHSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVptWm1ZN0lHWnNiMkYwT2lCdWIyNWxPeUJrYVhOd2JHRjVPaUJwYm14cGJtVWdJV2x0Y0c5eWRHRnVkRHNpUHRDUTBZRFF2TkN3MFlMUmc5R0EwTEFtSTNoa093b2cwWVEySU5DUU1qUXcwS0VnTVRMUXZDWmhiWEE3Ym1KemNEc2dMU0F3TERQUmd0QzlKbXgwT3k5emNHRnVQaVpzZER0aWNqNG1JM2hrT3dvbWJIUTdMMlJwZGo0bUkzaGtPd29tYkhRN1pHbDJQaVpzZER0emNHRnVJSE4wZVd4bFBTSmpiMnh2Y2pvZ0l6QXdNREF3TURzZ1ptOXVkQzFtWVcxcGJIazZJR0Z5YVdGc0xDQm9aV3gyWlhScFkyRXNJSE5oYm5NdGMyVnlhV1k3SUdadmJuUXRjMmw2WlRvZ01UWndlRHNnWm05dWRDMXpkSGxzWlRvZ2JtOXliV0ZzT3lCbWIyNTBMWGRsYVdkb2REb2dOREF3T3lCc1pYUjBaWEl0YzNCaFkybHVaem9nYm05eWJXRnNPeUIwWlhoMExXbHVaR1Z1ZERvZ01IQjRPeUIwWlhoMExYUnlZVzV6Wm05eWJUb2dibTl1WlRzZ2QyOXlaQzF6Y0dGamFXNW5PaUF3Y0hnN0lIZG9hWFJsTFhOd1lXTmxPaUJ1YjNKdFlXdzdJR0poWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1abVptWTdJR1pzYjJGME9pQnViMjVsT3lCa2FYTndiR0Y1T2lCcGJteHBibVVnSVdsdGNHOXlkR0Z1ZERzaUlHUmhkR0V0YldObExYTjBlV3hsUFNKamIyeHZjam9nSXpBd01EQXdNRHNnWm05dWRDMW1ZVzFwYkhrNklHRnlhV0ZzTENCb1pXeDJaWFJwWTJFc0lITmhibk10YzJWeWFXWTdJR1p2Ym5RdGMybDZaVG9nTVRad2VEc2dabTl1ZEMxemRIbHNaVG9nYm05eWJXRnNPeUJtYjI1MExYZGxhV2RvZERvZ05EQXdPeUJzWlhSMFpYSXRjM0JoWTJsdVp6b2dibTl5YldGc095QjBaWGgwTFdsdVpHVnVkRG9nTUhCNE95QjBaWGgwTFhSeVlXNXpabTl5YlRvZ2JtOXVaVHNnZDI5eVpDMXpjR0ZqYVc1bk9pQXdjSGc3SUhkb2FYUmxMWE53WVdObE9pQnViM0p0WVd3N0lHSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVptWm1ZN0lHWnNiMkYwT2lCdWIyNWxPeUJrYVhOd2JHRjVPaUJwYm14cGJtVWdJV2x0Y0c5eWRHRnVkRHNpUHRHRTBMalF1dEdCMExEUmd0QyswWUFtSTNoa093b2cwTERSZ05DODBMRFJndEdEMFlEUml5RFF2OUMrMFlMUXZ0QzcwTDdSaDlDOTBMRFJqeURRdnRDLzBMN1JnTkN3SURZd01ERFJpTkdDSm14ME95OXpjR0Z1UGlac2REc3ZaR2wyUGlZamVHUTdDaVpzZERzdlpHbDJQaVlqZUdRN0NpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjam9nSXpBd01EQXdNRHNnWm05dWRDMW1ZVzFwYkhrNklHRnlhV0ZzTENCb1pXeDJaWFJwWTJFc0lITmhibk10YzJWeWFXWTdJR1p2Ym5RdGMybDZaVG9nTVRad2VEc2dabTl1ZEMxemRIbHNaVG9nYm05eWJXRnNPeUJtYjI1MExYWmhjbWxoYm5RdGJHbG5ZWFIxY21Wek9pQnViM0p0WVd3N0lHWnZiblF0ZG1GeWFXRnVkQzFqWVhCek9pQnViM0p0WVd3N0lHWnZiblF0ZDJWcFoyaDBPaUEwTURBN0lHeGxkSFJsY2kxemNHRmphVzVuT2lCdWIzSnRZV3c3SUc5eWNHaGhibk02SURJN0lIUmxlSFF0WVd4cFoyNDZJSE4wWVhKME95QjBaWGgwTFdsdVpHVnVkRG9nTUhCNE95QjBaWGgwTFhSeVlXNXpabTl5YlRvZ2JtOXVaVHNnZDJsa2IzZHpPaUF5T3lCM2IzSmtMWE53WVdOcGJtYzZJREJ3ZURzZ0xYZGxZbXRwZEMxMFpYaDBMWE4wY205clpTMTNhV1IwYURvZ01IQjRPeUIzYUdsMFpTMXpjR0ZqWlRvZ2JtOXliV0ZzT3lCaVlXTnJaM0p2ZFc1a0xXTnZiRzl5T2lBalptUm1aR1prT3lCMFpYaDBMV1JsWTI5eVlYUnBiMjR0ZEdocFkydHVaWE56T2lCcGJtbDBhV0ZzT3lCMFpYaDBMV1JsWTI5eVlYUnBiMjR0YzNSNWJHVTZJR2x1YVhScFlXdzdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMWpiMnh2Y2pvZ2FXNXBkR2xoYkRzZ1pHbHpjR3hoZVRvZ2FXNXNhVzVsSUNGcGJYQnZjblJoYm5RN0lHWnNiMkYwT2lCdWIyNWxPeUlnWkdGMFlTMXRZMlV0YzNSNWJHVTlJbU52Ykc5eU9pQWpNREF3TURBd095Qm1iMjUwTFdaaGJXbHNlVG9nWVhKcFlXd3NJR2hsYkhabGRHbGpZU3dnYzJGdWN5MXpaWEpwWmpzZ1ptOXVkQzF6YVhwbE9pQXhObkI0T3lCbWIyNTBMWE4wZVd4bE9pQnViM0p0WVd3N0lHWnZiblF0ZG1GeWFXRnVkQzFzYVdkaGRIVnlaWE02SUc1dmNtMWhiRHNnWm05dWRDMTJZWEpwWVc1MExXTmhjSE02SUc1dmNtMWhiRHNnWm05dWRDMTNaV2xuYUhRNklEUXdNRHNnYkdWMGRHVnlMWE53WVdOcGJtYzZJRzV2Y20xaGJEc2diM0p3YUdGdWN6b2dNanNnZEdWNGRDMWhiR2xuYmpvZ2MzUmhjblE3SUhSbGVIUXRhVzVrWlc1ME9pQXdjSGc3SUhSbGVIUXRkSEpoYm5ObWIzSnRPaUJ1YjI1bE95QjNhV1J2ZDNNNklESTdJSGR2Y21RdGMzQmhZMmx1WnpvZ01IQjRPeUF0ZDJWaWEybDBMWFJsZUhRdGMzUnliMnRsTFhkcFpIUm9PaUF3Y0hnN0lIZG9hWFJsTFhOd1lXTmxPaUJ1YjNKdFlXdzdJR0poWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWkdaa1ptUTdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMTBhR2xqYTI1bGMzTTZJR2x1YVhScFlXdzdJSFJsZUhRdFpHVmpiM0poZEdsdmJpMXpkSGxzWlRvZ2FXNXBkR2xoYkRzZ2RHVjRkQzFrWldOdmNtRjBhVzl1TFdOdmJHOXlPaUJwYm1sMGFXRnNPeUJrYVhOd2JHRjVPaUJwYm14cGJtVWdJV2x0Y0c5eWRHRnVkRHNnWm14dllYUTZJRzV2Ym1VN0lqN1F2OUdBMEw3UXN0QyswTHZRdnRDNjBMQW1JM2hrT3dvZzBMTFJqOUMzMExEUXU5R00wTDNRc05HUElERXNNdEM4MEx3Z0xTQXlNemZRdXRDekpteDBPeTl6Y0dGdVBpWnNkRHNoTFMxRmJtUkdjbUZuYldWdWRDMHRQaVlqZUdRN0NpWnNkRHRrYVhZZ2MzUjViR1U5SW1Oc1pXRnlPaUJpYjNSb095SWdaR0YwWVMxdFkyVXRjM1I1YkdVOUltTnNaV0Z5T2lCaWIzUm9PeUkrSm14ME8ySnlJR1JoZEdFdGJXTmxMV0p2WjNWelBTSXhJajRtSTNoa093b21iSFE3TDJScGRqNG1JM2hrT3dvbWJIUTdMMlJwZGo0bUkzaGtPd29tYkhRN1pHbDJJR1JoZEdFdGJXRnlhMlZ5UFNKZlgxTkpSMTlRVDFOVVgxOGlQaTB0SUNac2REdGljajRtSTNoa093b21iSFE3TDJScGRqNG1JM2hrT3dvbWJIUTdaR2wyUHRDaElOR0QwTExRc05DMjBMWFF2ZEM0MExYUXZDd2cwTHZRdnRDejBMalJnZEdDSm14ME8ySnlQaVlqZUdRN0N0QzYwTDdRdk5DLzBMRFF2ZEM0MExnZ0ptRnRjRHR4ZFc5ME85Q2EwWURRdnRDeTBMWFF1OUdNMEwzUmk5QzVJTkNtMExYUXZkR0MwWUFtWVcxd08zRjFiM1E3Sm14ME8ySnlQaVlqZUdRN0N0Q2EwTERRdWRDMDBMRFF1OUM0MEwzUXNDRFFudEM2MFlIUXNOQzkwTEFnMEozUXVOQzYwTDdRdTlDdzBMWFFzdEM5MExBbWJIUTdZbkkrSmlONFpEc0swTE11SU5DYTBZRFFzTkdCMEwzUXZ0R1AwWURSZ2RDNkpteDBPMkp5UGlZamVHUTdDdEdDMExYUXV5NGdPRGs0TXpJMk5qUXpNekFtYkhRN1luSStKaU40WkRzSzBMclJnTkMrMExMUXRkQzcwWXpRdmRHTDBMblJodEMxMEwzUmd0R0FMdEdBMFlRdkpteDBPeTlrYVhZK0ppTjRaRHNLSm14ME95OWthWFkrSmlONFpEc0tKbXgwT3k5a2FYWStKaU40WkRzS0pteDBPeTlpYjJSNVBpWWplR1E3Q2lac2REc3ZhSFJ0YkQ0bUkzaGtPd284TDJacGJHVkRiMjUwWlc1MFBqd3Zhbk52Yms5aWFtVmpkRDQ4TDNOdllYQmxiblk2UW05a2VUNDhMM052WVhCbGJuWTZSVzUyWld4dmNHVSs=')