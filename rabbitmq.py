import xml.etree.ElementTree as ET
import re
import asyncio
import aio_pika
import base64
import json
from distance import Find_materials
from datetime import datetime
from functools import partial
from hash2text import text_from_hash
from split_by_keys import Key_words
from yandexgpt import custom_yandex_gpt
import config as conf
from thread import Thread

class Order_recognition():

    def __init__(self):
        self.find_mats = Find_materials()

    def write_logs(self, text, event=1):
        event = 'EVENT' if event == 1 else 'ERROR'
        date_time = datetime.now().astimezone()
        file_name = './logs/' + str(date_time.date()) + '.txt'
        with open(file_name, 'a', encoding="utf-8") as file:
            file.write(str(date_time) + ' | ' + event + ' | ' + text + '\n')

    def consumer_test(self, hash:str=None, content:str=None):
        if content is None:
            content = text_from_hash(hash)
            print('Text - ', content.split('\n'), flush=True)
        # self.test_analize_email(content)
        my_thread = Thread(target=self.test_analize_email, args=[content])
        my_thread.start()

    def test_analize_email(self, content):
        ygpt = custom_yandex_gpt()
        clear_email = ygpt.big_mail(content, False)
        # Отправляем распознаннaй текст(!) на поиск материалов
        print('Очищенное сообщение -', clear_email)
        results = str(self.find_mats.paralell_rows(clear_email))
        self.write_logs('results - ' + results, 1)
        print('results = ', results)
        # self.send_result(results)

    def save_truth_test(self, content):
        if 'true_value' not in str(content):
            return
        self.write_logs('Получилось взять ответы МЕТОД 2', 1)
        print('Получилось взять ответы МЕТОД 2', flush=True)
        body = json.loads(content)
        print("METHOD 2 - ", body, flush=True)
        self.write_logs('METHOD 2 - ' + str(body), 1)
        req_Number = body['req_number']
        if req_Number in self.find_mats.saves.index:
            positions = json.loads(self.find_mats.saves.loc[req_Number]['positions'].replace("'", '"'))['positions']
            true_positions = body['positions']
            for ind, pos in enumerate(true_positions):
                if int(pos['true_material']) == int(positions[int(pos['position_id'])]['material1_id']):
                    continue
                request_text = positions[int(pos['position_id'])]['request_text']
                request_text = self.find_mats.new_mat_prep(request_text)
                request_text = request_text.strip()
                try:
                    true_mat = self.find_mats.all_materials[self.find_mats.all_materials['Материал']. \
                        str.contains(str(int(pos['true_material'])))]['Полное наименование материала'].values[0]
                    true_first = self.find_mats.all_materials[self.find_mats.all_materials['Материал']
                                                              == (str(int(pos['true_material'])))][
                        'Название иерархии-1'].values[0]
                    # true_mat = str(int(pos['true_material']))

                except Exception as exc:
                    self.write_logs('Не нашёл такого материала ' + str(pos['true_material']) + ' ' + str(exc), event=0)
                    continue
                try:
                    print(self.find_mats.all_materials[self.find_mats.all_materials['Материал']
                                                       == (str(int(pos['true_material'])))])
                    print('Отправляем обучать !', flush=True)
                    self.write_logs('Отправляем обучать ! ' + request_text + '|' + true_first)
                    self.find_mats.models.fit(request_text, true_first)
                except Exception as exc:
                    self.write_logs('Не смог обучить модельки для ' + str(pos['true_material']) + ' ' + str(exc),
                                    event=0)
                    continue

                if 'spec_mat' in pos.keys():
                    this_client_only = True if pos['spec_mat'] == 'X' else False
                else:
                    this_client_only = False
                res = str({'num_mat': str(int(pos['true_material'])),
                           'name_mat': true_mat,
                           'true_ei': pos['true_ei'],
                           'true_value': pos['true_value'],
                           'spec_mat': str(this_client_only)})
                res = base64.b64encode(bytes(res, 'utf-8'))
                # self.find_mats.method2.loc[request_text] = res.decode('utf-8')
                # print(self.find_mats.method2.index)
                self.find_mats.method2.loc[len(self.find_mats.method2.index)] = [request_text, res.decode('utf-8')]
            self.find_mats.method2.to_csv('data/method2.csv', index=False)
        else:
            self.write_logs('Не нашёл такого письма', event=0)
            print('Не нашёл такого письма', flush=True)
        print("Метод 2 всё", flush=True)

    async def save_truth(self,
            msg: aio_pika.IncomingMessage):
        # используем контекстный менеджер для ack'а сообщения
        async with msg.process():
            content = msg.body
            if 'true_value' not in str(content):
                return
            self.write_logs('Получилось взять ответы МЕТОД 2', 1)
            print('Получилось взять ответы МЕТОД 2', flush=True)
            body = json.loads(content)
            print("METHOD 2 - ", body, flush=True)
            self.write_logs('METHOD 2 - ' + str(body), 1)
            req_Number = body['req_number']
            if req_Number in self.find_mats.saves.index:
                positions = json.loads(self.find_mats.saves.loc[req_Number]['positions'].replace("'", '"'))['positions']
                true_positions = body['positions']
                for ind, pos in enumerate(true_positions):
                    if int(pos['true_material']) == int(positions[int(pos['position_id'])]['material1_id']):
                        continue
                    request_text = positions[int(pos['position_id'])]['request_text']
                    request_text = self.find_mats.new_mat_prep(request_text)
                    request_text = request_text.strip()
                    try:
                        true_mat = self.find_mats.all_materials[self.find_mats.all_materials['Материал'].\
                            str.contains(str(int(pos['true_material'])))]['Полное наименование материала'].values[0]
                        true_first = self.find_mats.all_materials[self.find_mats.all_materials['Материал']
                                                     == (str(int(pos['true_material'])))]['Название иерархии-1'].values[0]
                        # true_mat = str(int(pos['true_material']))

                    except Exception as exc:
                        self.write_logs('Не нашёл такого материала '+str(pos['true_material']) + ' ' + str(exc), event=0)
                        continue
                    try:
                        print(self.find_mats.all_materials[self.find_mats.all_materials['Материал']
                                                           == (str(int(pos['true_material'])))])
                        print('Отправляем обучать !', flush=True)
                        self.write_logs('Отправляем обучать ! ' + request_text + '|' + true_first)
                        self.find_mats.models.fit(request_text, true_first)
                    except Exception as exc:
                        self.write_logs('Не смог обучить модельки для '+str(pos['true_material']) + ' ' + str(exc), event=0)
                        continue

                    if 'spec_mat' in pos.keys():
                        this_client_only = True if pos['spec_mat'] == 'X' else False
                    else:
                        this_client_only = False
                    res = str({'num_mat':str(int(pos['true_material'])),
                                'name_mat':true_mat,
                                'true_ei':pos['true_ei'],
                                'true_value':pos['true_value'],
                                'spec_mat':str(this_client_only)})
                    res = base64.b64encode(bytes(res, 'utf-8'))
                    # self.find_mats.method2.loc[request_text] = res.decode('utf-8')
                    # print(self.find_mats.method2.index)
                    self.find_mats.method2.loc[len(self.find_mats.method2.index)] = [request_text, res.decode('utf-8')]
                self.find_mats.method2.to_csv('data/method2.csv', index=False)
            else:
                self.write_logs('Не нашёл такого письма', event=0)
                print('Не нашёл такого письма', flush=True)
            print("Метод 2 всё", flush=True)

    def start_analize_email(self, content, msg, channel):
        print('Начало потока!', flush=True)
        ygpt = custom_yandex_gpt()
        clear_email = ygpt.big_mail(content)
        # Отправляем распознанный текст(!) на поиск материалов
        print('Clear email - ', clear_email)
        results = str(self.find_mats.paralell_rows(clear_email))
        self.write_logs('results - ' + results, 1)
        print('results = ', results)
        # self.send_result(results)
        # проверяем, требует ли сообщение ответа
        if msg.reply_to:
            # отправляем ответ в default exchange
            print('Отправляем результат', flush=True)
            self.write_logs('Отправляем результaт', 1)
            asyncio.run(channel.default_exchange.publish(
                message=aio_pika.Message(
                    content_type='application/json',
                    body=str.encode(results.replace("'", '"')[1:-1]),
                    # body=b'{"a":"b"}',
                    correlation_id=msg.correlation_id
                ),
                routing_key=msg.reply_to,  # самое важное

            ))
        print('Конец!', flush=True)

    async def consumer(self,
            msg: aio_pika.IncomingMessage,
            channel: aio_pika.RobustChannel,
    ):
        # используем контекстный менеджер для ack'а сообщения
        async with msg.process():
            print('Что-то получил из очереди rebbitmq...', flush=True)
            content = msg.body
            if 'true_value' in str(content):
                return
            self.write_logs('Получилось взять письмо из очереди', 0)
            print('Получилось взять письмо из очереди', flush=True)
            body = json.loads(content)
            self.write_logs('Body - ' + str(body), 1)
            if len(body['email']) == 0:
                print('Письмо пустое!!!', flush=True)
                self.write_logs('Письмо пустое!!!', 1)
            content = text_from_hash(body['email'])
            # await self.start_analize_email(content, msg, channel)
            my_thread = Thread(target=self.start_analize_email, args=[content, msg, channel])
            my_thread.start()
            # my_thread.join()

    def get_message(self, body):
        body = json.loads(body)
        print(body)

        try:
            content = base64.standard_b64decode(base64.standard_b64decode(body['email']))\
                .decode('utf-8')
            root = ET.fromstring(content)
            content = root[0][0][2].text
            content = re.sub(r'\<.*?\>', '', content).replace('&nbsp;', '')
        except Exception as exc:
            self.write_logs('Письмо не читается,'+str(exc), 0)
            print('Error, письмо не читается,', exc)
            return 'Error while reading'
        return content

    async def main(self):
        connection = await aio_pika.connect_robust(
            conf.connection_url
        )


        async with connection:
            channel = await connection.channel()
            queue = await channel.declare_queue(conf.first_queue, timeout=60000)
            # через partial прокидываем в наш обработчик сам канал
            await queue.consume(partial(self.consumer, channel=channel), timeout=60000)
            print('Слушаем очередь', flush=True)


            queue2 = await channel.declare_queue(conf.second_queue, timeout=10000)
            await queue2.bind(exchange=conf.exchange, routing_key=conf.routing_key, timeout=10000)
            # через partial прокидываем в наш обработчик сам канал
            await queue2.consume(partial(self.save_truth), timeout=10000)
            print('Слушаем очередь 2', flush=True)
            try:
                await asyncio.Future()
            except Exception:
                pass

    def start(self):
        asyncio.run(self.main())

if __name__ == '__main__':
    order_rec = Order_recognition()
    order_rec.start()
    # order_rec.consumer_test(content="""Лист Г/К 2 1.25м 2.5м ст3пс5/сп5 16523 Ф""")
    # order_rec.consumer_test(content="""22. Труба профильная 75x750x0.9 L 6000 9 шт""")
    # order_rec.consumer_test(hash='UEQ5NGJXd2dkbVZ5YzJsdmJqMG5NUzR3SnlCbGJtTnZaR2x1WnowbmRYUm1MVGduUHo0OGMyOWhjR1Z1ZGpwRmJuWmxiRzl3WlNCNGJXeHVjenB6YjJGd1pXNTJQU0pvZEhSd09pOHZjMk5vWlcxaGN5NTRiV3h6YjJGd0xtOXlaeTl6YjJGd0wyVnVkbVZzYjNCbEx5SStQSE52WVhCbGJuWTZRbTlrZVQ0OGFuTnZiazlpYW1WamRENDhiMkpxWldOMFRtRnRaVDV0YzJkZk5qTmpPREUzWkRjd01tVTROamMxT1dRMlpUYzBNalk1WWpnelpqSmpZMlU4TDI5aWFtVmpkRTVoYldVK1BHSjFZMnRsZEU1aGJXVStZM0p0TFdWdFlXbHNQQzlpZFdOclpYUk9ZVzFsUGp4bWFXeGxRMjl1ZEdWdWRENG1iSFE3YUhSdGJENG1JM2hrT3dvbWJIUTdhR1ZoWkQ0bUkzaGtPd29tYkhRN2JXVjBZU0JvZEhSd0xXVnhkV2wyUFNKRGIyNTBaVzUwTFZSNWNHVWlJR052Ym5SbGJuUTlJblJsZUhRdmFIUnRiRHNnWTJoaGNuTmxkRDExZEdZdE9DSStKaU40WkRzS0pteDBPeTlvWldGa1BpWWplR1E3Q2lac2REdGliMlI1UGlZamVHUTdDaVpzZER0d0lITjBlV3hsUFNKbWIyNTBMWE5wZW1VNk1UQndkRHNnWTI5c2IzSTZJekF3TURCbVppSStKbXgwTzJrKzBKTFFuZENWMEtqUW5kQ3YwSzhnMEovUW50Q24wS0xRa0RvZzBKWFJnZEM3MExnZzBMN1JndEMvMFlEUXNOQ3kwTGpSZ3RDMTBMdlJqQ0RRdmRDMTBMalF0OUN5MExYUmdkR0MwTFhRdlN3ZzBMM1F0U0RRdjlDMTBZRFF0ZEdGMEw3UXROQzQwWUxRdFNEUXY5QytJTkdCMFlIUmk5QzcwTHJRc05DOExDRFF2ZEMxSU5DKzBZTFF2OUdBMExEUXN0QzcwWS9RdWRHQzBMVWcwTC9Rc05HQTBMN1F1OUM0TENEUmdTRFF2dEdCMFlMUXZ0R0EwTDdRdHRDOTBMN1JnZEdDMFl6UmppRFF2dEdDMExyUmdOR0wwTExRc05DNTBZTFF0U0RRc3RDNzBMN1F0dEMxMEwzUXVOR1BMaVpzZERzdmFUNG1iSFE3TDNBK0ppTjRaRHNLSm14ME8ySnlQaVlqZUdRN0NpWnNkRHRpY2o0bUkzaGtPd29tYkhRN1luSStKaU40WkRzS0pteDBPMkp5UGlZamVHUTdDaVpzZER0a2FYWStKaU40WkRzS0pteDBPM0FnYzNSNWJHVTlJbTFoY21kcGJpMTBiM0E2SURCd2VEc2lJR1JwY2owaWJIUnlJajRtYkhRN0wzQStKaU40WkRzS0pteDBPMlJwZGlCcFpEMGliV0ZwYkMxaGNIQXRZWFYwYnkxa1pXWmhkV3gwTFhOcFoyNWhkSFZ5WlNJK0ppTjRaRHNLSm14ME8zQWdaR2x5UFNKc2RISWlQaTB0Sm14ME8ySnlQaVlqZUdRN0N0Q2UwWUxRdjlHQTBMRFFzdEM3MExYUXZkQytJTkM0MExjZ1RXRnBiQzV5ZFNEUXROQzcwWThnUVc1a2NtOXBaQ1pzZERzdmNENG1JM2hrT3dvbWJIUTdMMlJwZGo0bUkzaGtPd290TFMwdExTMHRMU0RRbjlDMTBZRFF0ZEdCMEx2UXNOQzkwTDNRdnRDMUlOQy8wTGpSZ2RHTTBMelF2aUF0TFMwdExTMHRMU1pzZER0aWNqNG1JM2hrT3dyUW50R0NPaURRcU5DdzBZRFF1TkMvMEw3UXNpRFFsTkN3MEx6UXVOR0FJTkNZMFlEUXRkQzYwTDdRc3RDNDBZY2dKbXgwTzJFZ2FISmxaajBpYldGcGJIUnZPbk5vWVhKcGNHOTJaR2xBYzNCckxuSjFJajV6YUdGeWFYQnZkbVJwUUhOd2F5NXlkU1pzZERzdllUNG1iSFE3WW5JK0ppTjRaRHNLMEpyUXZ0QzgwWU02SUVSaGJXbHlJRk5vWVhKcGNHOTJJQ1pzZER0aElHaHlaV1k5SW0xaGFXeDBienBrWVcxcGNpNXphR0Z5YVhCdmRqSXpRRzFoYVd3dWNuVWlQbVJoYldseUxuTm9ZWEpwY0c5Mk1qTkFiV0ZwYkM1eWRTWnNkRHN2WVQ0bWJIUTdZbkkrSmlONFpEc0swSlRRc05HQzBMQTZJTkdCMFlEUXRkQzAwTEFzSURJMElOQzQwWTdRdTlHUElESXdNalRRc3k0c0lERXpPakkzSUNaaGJYQTdJelF6T3pBMU9qQXdKbXgwTzJKeVBpWWplR1E3Q3RDaTBMWFF2TkN3T2lEUWw5Q3cwWS9Rc3RDNjBMQW1iSFE3WW5JK0ppTjRaRHNLSm14ME8ySnlQaVlqZUdRN0NpWnNkRHRpYkc5amEzRjFiM1JsSUdsa1BTSnRZV2xzTFdGd2NDMWhkWFJ2TFhGMWIzUmxJaUJqYVhSbFBTSXhOekl4T0RBNU5qWTBNVGsxTlRnNU1qZ3lPU0lnYzNSNWJHVTlJbUp2Y21SbGNpMXNaV1owT2pGd2VDQnpiMnhwWkNBak1EQTFSa1k1T3lCdFlYSm5hVzQ2TUhCNElEQndlQ0F3Y0hnZ01UQndlRHNnY0dGa1pHbHVaem93Y0hnZ01IQjRJREJ3ZUNBeE1IQjRPeUkrSmlONFpEc0tKbXgwTzJScGRpQmpiR0Z6Y3owaWFuTXRhR1ZzY0dWeUlHcHpMWEpsWVdSdGMyY3RiWE5uSWo0bWJIUTdjM1I1YkdVZ2RIbHdaVDBpZEdWNGRDOWpjM01pUGlac2REc3ZjM1I1YkdVK0pteDBPMkpoYzJVZ2RHRnlaMlYwUFNKZmMyVnNaaUlnYUhKbFpqMGlhSFIwY0hNNkx5OWxMbTFoYVd3dWNuVXZJajRtSTNoa093b21iSFE3WkdsMklHbGtQU0p6ZEhsc1pWOHhOekl4T0RBNU5qWTBNVGsxTlRnNU1qZ3lPU0krSmlONFpEc0tKbXgwTzJScGRpQnBaRDBpYzNSNWJHVmZNVGN5TVRnd09UWTJOREU1TlRVNE9USTRNamxmUWs5RVdTSStKaU40WkRzS0pteDBPMlJwZGlCamJHRnpjejBpWTJ4Zk9ERTROekl4SWo0bUkzaGtPd29tYkhRN1pHbDJJR05zWVhOelBTSlhiM0prVTJWamRHbHZiakZmYlhKZlkzTnpYMkYwZEhJaVBpWWplR1E3Q2lac2REdDBZV0pzWlNCamJHRnpjejBpVFhOdlRtOXliV0ZzVkdGaWJHVmZiWEpmWTNOelgyRjBkSElpSUdKdmNtUmxjajBpTUNJZ1kyVnNiSE53WVdOcGJtYzlJakFpSUdObGJHeHdZV1JrYVc1blBTSXdJaUIzYVdSMGFEMGlNQ0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN1ltOXlaR1Z5TFdOdmJHeGhjSE5sT21OdmJHeGhjSE5sSWo0bUkzaGtPd29tYkhRN2RHSnZaSGsrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHR3WVdSa2FXNW5PakJqYlNBMUxqUndkQ0F3WTIwZ05TNDBjSFE3YUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM0FnWTJ4aGMzTTlJazF6YjA1dmNtMWhiRjl0Y2w5amMzTmZZWFIwY2lJK0pteDBPM053WVc0Z2MzUjViR1U5SW1OdmJHOXlPbUpzWVdOck8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWSWo3UW05QzQwWUhSZ2lEUWt5L1FtaUF5SURFdU1qWFF2Q0F5TGpYUXZDRFJnZEdDTTlDLzBZRTFMOUdCMEw4MUlERTJOVEl6SU5Da0pteDBPeTl6Y0dGdVBpWnNkRHN2Y0Q0bUkzaGtPd29tYkhRN0wzUmtQaVlqZUdRN0NpWnNkRHN2ZEhJK0ppTjRaRHNLSm14ME8zUnlJSE4wZVd4bFBTSm9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2RHUWdkMmxrZEdnOUlqSTROU0lnYm05M2NtRndQU0lpSUhaaGJHbG5iajBpWW05MGRHOXRJaUJ6ZEhsc1pUMGlkMmxrZEdnNk1qRTBMakJ3ZER0d1lXUmthVzVuT2pCamJTQTFMalJ3ZENBd1kyMGdOUzQwY0hRN2FHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNBZ1kyeGhjM005SWsxemIwNXZjbTFoYkY5dGNsOWpjM05mWVhSMGNpSStKbXgwTzNOd1lXNGdjM1I1YkdVOUltTnZiRzl5T21Kc1lXTnJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVklqN1FtOUM0MFlIUmdpRFFudENtSURBdU5TQXhMakkxMEx3Z01pNDEwTHdnV200eE5EQWcwWUhSZ3RDdzBMMGdNVEl3TUNBd0pteDBPeTl6Y0dGdVBpWnNkRHN2Y0Q0bUkzaGtPd29tYkhRN0wzUmtQaVlqZUdRN0NpWnNkRHN2ZEhJK0ppTjRaRHNLSm14ME8zUnlJSE4wZVd4bFBTSm9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2RHUWdkMmxrZEdnOUlqSTROU0lnYm05M2NtRndQU0lpSUhaaGJHbG5iajBpWW05MGRHOXRJaUJ6ZEhsc1pUMGlkMmxrZEdnNk1qRTBMakJ3ZER0d1lXUmthVzVuT2pCamJTQTFMalJ3ZENBd1kyMGdOUzQwY0hRN2FHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNBZ1kyeGhjM005SWsxemIwNXZjbTFoYkY5dGNsOWpjM05mWVhSMGNpSStKbXgwTzNOd1lXNGdjM1I1YkdVOUltTnZiRzl5T21Kc1lXTnJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVklqN1FtOUM0MFlIUmdpRFFuOUNTMEpzZ05EQTRJTkNmMEpJeUlOR0IwWUl6MEwvUmdUVXYwWUhRdnpVbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVBrUkpXU0RRb2RDMTBZTFF1dEN3SU5HQjBMTFFzTkdBMEwzUXNOR1BJRFBRa3RHQU1TQXowSkxSZ0RFZ01UQXdJREV3TUNBeDBMd2dNaVpzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdjR0ZrWkdsdVp6b3dZMjBnTlM0MGNIUWdNR050SURVdU5IQjBPMmhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdHdJR05zWVhOelBTSk5jMjlPYjNKdFlXeGZiWEpmWTNOelgyRjBkSElpUGlac2REdHpjR0Z1SUhOMGVXeGxQU0pqYjJ4dmNqcGliR0ZqYXp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEtQUXM5QyswTHZRdnRDNklERXlOU0F4TWpVZ09DQXhNdEM4SU5HQjBZSXowTC9SZ1RVdjBZSFF2elVnT0RVd09TQXhNaXdtYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHQwWkNCM2FXUjBhRDBpTWpnMUlpQnViM2R5WVhBOUlpSWdkbUZzYVdkdVBTSmliM1IwYjIwaUlITjBlV3hsUFNKM2FXUjBhRG95TVRRdU1IQjBPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZZbXhoWTJzN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDaTBZRFJnOUN4MExBZzBML1JnTkMrMFlUUXVOQzcwWXpRdmRDdzBZOGdNVEF3SURFd01DQTJKaU40WkRzS0pteDBPM053WVc0Z1kyeGhjM005SW1wekxYQm9iMjVsTFc1MWJXSmxjaUkrT0RZek9TOHpNREkwTlNac2REc3ZjM0JoYmo0bWJIUTdMM053WVc0K0pteDBPeTl3Sm1kME95WWplR1E3Q2lac2REc3ZkR1ErSmlONFpEc0tKbXgwT3k5MGNqNG1JM2hrT3dvbWJIUTdkSElnYzNSNWJHVTlJbWhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdDBaQ0IzYVdSMGFEMGlNamcxSWlCdWIzZHlZWEE5SWlJZ2RtRnNhV2R1UFNKaWIzUjBiMjBpSUhOMGVXeGxQU0ozYVdSMGFEb3lNVFF1TUhCME8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNllteGhZMnM3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVWlQdENmMFlEUXZ0R0UwTDNRc05HQjBZTFF1TkM3SU5DZTBLWWcwS0U0SURBdU5EVWdNVEUxTUM4eE1qQXdKbXgwT3k5emNHRnVQaVpzZERzdmNENG1JM2hrT3dvbWJIUTdMM1JrUGlZamVHUTdDaVpzZERzdmRISStKaU40WkRzS0pteDBPM1J5SUhOMGVXeGxQU0pvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdkR1FnZDJsa2RHZzlJakk0TlNJZ2JtOTNjbUZ3UFNJaUlIWmhiR2xuYmowaVltOTBkRzl0SWlCemRIbHNaVDBpZDJsa2RHZzZNakUwTGpCd2REdHdZV1JrYVc1bk9qQmpiU0ExTGpSd2RDQXdZMjBnTlM0MGNIUTdhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zQWdZMnhoYzNNOUlrMXpiMDV2Y20xaGJGOXRjbDlqYzNOZllYUjBjaUkrSm14ME8zTndZVzRnYzNSNWJHVTlJbU52Ykc5eU9tSnNZV05yTzIxemJ5MW1ZWEpsWVhOMExXeGhibWQxWVdkbE9sSlZJaVpuZER2UW05QzQwWUhSZ2lEUWt5L1FtaUF4TkNBeExqWFF2Q0EyMEx3ZzBZSFJnalBRdjlHQk5TL1JnZEMvTlNBeE5EWXpOeUEyTERBbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q2IwTGpSZ2RHQ0lOQ1RMOUNhSURFd0lERXVOZEM4SURiUXZDRFJnZEdDTTlDLzBZRTFMOUdCMEw4MUlERTBOak0zSU5Da0lEWW1iSFE3TDNOd1lXNCtKbXgwT3k5d1BpWWplR1E3Q2lac2REc3ZkR1ErSmlONFpEc0tKbXgwT3k5MGNqNG1JM2hrT3dvbWJIUTdkSElnYzNSNWJHVTlJbWhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdDBaQ0IzYVdSMGFEMGlNamcxSWlCdWIzZHlZWEE5SWlJZ2RtRnNhV2R1UFNKaWIzUjBiMjBpSUhOMGVXeGxQU0ozYVdSMGFEb3lNVFF1TUhCME8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNllteGhZMnM3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVWlQdENqMExQUXZ0QzcwTDdRdWlBNU1DQTVNQ0E0SURFeTBMd2cwWUhSZ2pQUXY5R0JOUy9SZ2RDL05TQTROVEE1SURFeUxEQXdKbXgwT3k5emNHRnVQaVpzZERzdmNENG1JM2hrT3dvbWJIUTdMM1JrUGlZamVHUTdDaVpzZERzdmRISStKaU40WkRzS0pteDBPM1J5SUhOMGVXeGxQU0pvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdkR1FnZDJsa2RHZzlJakk0TlNJZ2JtOTNjbUZ3UFNJaUlIWmhiR2xuYmowaVltOTBkRzl0SWlCemRIbHNaVDBpZDJsa2RHZzZNakUwTGpCd2REdHdZV1JrYVc1bk9qQmpiU0ExTGpSd2RDQXdZMjBnTlM0MGNIUTdhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zQWdZMnhoYzNNOUlrMXpiMDV2Y20xaGJGOXRjbDlqYzNOZllYUjBjaUkrSm14ME8zTndZVzRnYzNSNWJHVTlJbU52Ykc5eU9tSnNZV05yTzIxemJ5MW1ZWEpsWVhOMExXeGhibWQxWVdkbE9sSlZJajdRbzlDejBMN1F1OUMrMExvZ01UUXdJREUwTUNBNUlERXkwTHdnMFlIUmdqUFF2OUdCTlMvUmdkQy9OU0E0TlRBNUlERXlMQ1pzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdjR0ZrWkdsdVp6b3dZMjBnTlM0MGNIUWdNR050SURVdU5IQjBPMmhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdHdJR05zWVhOelBTSk5jMjlPYjNKdFlXeGZiWEpmWTNOelgyRjBkSElpUGlac2REdHpjR0Z1SUhOMGVXeGxQU0pqYjJ4dmNqcGliR0ZqYXp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEtqUXN0QzEwTHZRdTlDMTBZQWdNVFlnMEtNZ01UTFF2Q0RSZ2RHQ005Qy8wWUUxTDlHQjBMODFJRGd5TkRBZ01USXNNREFtYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHQwWkNCM2FXUjBhRDBpTWpnMUlpQnViM2R5WVhBOUlpSWdkbUZzYVdkdVBTSmliM1IwYjIwaUlITjBlV3hsUFNKM2FXUjBhRG95TVRRdU1IQjBPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZZbXhoWTJzN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDUjBMRFF1OUM2MExBZ01qWFFxREVnTVRMUXZDRFFvVEkxTlNBMU56Z3pOeUF4TWl3d01DWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN1ltRmphMmR5YjNWdVpEb2pSa1pETjBORk8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNkl6bERNREF3Tmp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEp2UXVOR0IwWUlnMEwvUXZ0QzcwTGpRdk5DMTBZQXNJTkM2MExJdTBMd2dNQzQzSU5DZjBLMGdVa0ZNTlRBeE5TRFJnZEM0MEwzUXRkQzFKbXgwT3k5emNHRnVQaVpzZERzdmNENG1JM2hrT3dvbWJIUTdMM1JrUGlZamVHUTdDaVpzZERzdmRISStKaU40WkRzS0pteDBPM1J5SUhOMGVXeGxQU0pvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdkR1FnZDJsa2RHZzlJakk0TlNJZ2JtOTNjbUZ3UFNJaUlIWmhiR2xuYmowaVltOTBkRzl0SWlCemRIbHNaVDBpZDJsa2RHZzZNakUwTGpCd2REdHdZV1JrYVc1bk9qQmpiU0ExTGpSd2RDQXdZMjBnTlM0MGNIUTdhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zQWdZMnhoYzNNOUlrMXpiMDV2Y20xaGJGOXRjbDlqYzNOZllYUjBjaUkrSm14ME8zTndZVzRnYzNSNWJHVTlJbU52Ykc5eU9tSnNZV05yTzIxemJ5MW1ZWEpsWVhOMExXeGhibWQxWVdkbE9sSlZJajdRa05HQTBMelFzTkdDMFlQUmdOQ3dJRE13SURFeExqZlF2Q0RRa0RJME1DQXpOREF5T0MweE5pQXhNU3czTUNac2REc3ZjM0JoYmo0bWJIUTdMM0ErSmlONFpEc0tKbXgwT3k5MFpENG1JM2hrT3dvbWJIUTdMM1J5UGlZamVHUTdDaVpzZER0MGNpQnpkSGxzWlQwaWFHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNSa0lIZHBaSFJvUFNJeU9EVWlJRzV2ZDNKaGNEMGlJaUIyWVd4cFoyNDlJbUp2ZEhSdmJTSWdjM1I1YkdVOUluZHBaSFJvT2pJeE5DNHdjSFE3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjanBpYkdGamF6dHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlNJKzBKdlF1TkdCMFlJZzBKTXYwSm9nTmlBeExqWFF2Q0EyMEx3ZzBZSFJnalBRdjlHQk5TL1JnZEMvTlNBeE5EWXpOeURRcENBMkxDWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN2NHRmtaR2x1Wnpvd1kyMGdOUzQwY0hRZ01HTnRJRFV1TkhCME8yaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0d0lHTnNZWE56UFNKTmMyOU9iM0p0WVd4ZmJYSmZZM056WDJGMGRISWlQaVpzZER0emNHRnVJSE4wZVd4bFBTSmpiMnh2Y2pwaWJHRmphenR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZTSSswSnZRdU5HQjBZSWcwSk12MEpvZ09DQXhMalhRdkNBMjBMd2cwWUhSZ2pQUXY5R0JOUy9SZ2RDL05TQXhORFl6TnlEUXBDQTJMQ1pzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdjR0ZrWkdsdVp6b3dZMjBnTlM0MGNIUWdNR050SURVdU5IQjBPMmhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdHdJR05zWVhOelBTSk5jMjlPYjNKdFlXeGZiWEpmWTNOelgyRjBkSElpUGlac2REdHpjR0Z1SUhOMGVXeGxQU0pqYjJ4dmNqcGliR0ZqYXp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEpEUmdOQzgwTERSZ3RHRDBZRFFzQ0F5TUNBeE1TNDMwTHdnMEpBMU1EQWcwS0VnTXpRd01qZ3RNVFlnTVRFc056QW1iSFE3TDNOd1lXNCtKbXgwT3k5d1BpWWplR1E3Q2lac2REc3ZkR1ErSmlONFpEc0tKbXgwT3k5MGNqNG1JM2hrT3dvbWJIUTdkSElnYzNSNWJHVTlJbWhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdDBaQ0IzYVdSMGFEMGlNamcxSWlCdWIzZHlZWEE5SWlJZ2RtRnNhV2R1UFNKaWIzUjBiMjBpSUhOMGVXeGxQU0ozYVdSMGFEb3lNVFF1TUhCME8ySmhZMnRuY205MWJtUTZJMFpHUXpkRFJUdHdZV1JrYVc1bk9qQmpiU0ExTGpSd2RDQXdZMjBnTlM0MGNIUTdhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zQWdZMnhoYzNNOUlrMXpiMDV2Y20xaGJGOXRjbDlqYzNOZllYUjBjaUkrSm14ME8zTndZVzRnYzNSNWJHVTlJbU52Ykc5eU9pTTVRekF3TURZN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDZjBZRFF2dEN5MEw3UXU5QyswTHJRc0NCa01TNDBJTkN4MFlQUmhkR0MwTEFnMFlVeE5kQzlOakFnTVRJM05qWXVNU1pzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdZbUZqYTJkeWIzVnVaRG9qUmtaRE4wTkZPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZJemxETURBd05qdHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlNJKzBKL1JnTkMrMExMUXZ0QzcwTDdRdXRDd0lHUXhMalFnMExIUmc5R0YwWUxRc0NEUmhURTEwTDAyTUNBeE1qYzJOaTR4Sm14ME95OXpjR0Z1UGlac2REc3ZjRDRtSTNoa093b21iSFE3TDNSa1BpWWplR1E3Q2lac2REc3ZkSEkrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHRpWVdOclozSnZkVzVrT2lOR1JrTTNRMFU3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjam9qT1VNd01EQTJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVklqN1FuOUdBMEw3UXN0QyswTHZRdnRDNjBMQWdaREV1TkNEUXNkR0QwWVhSZ3RDd0lOR0ZNVFhRdlRZd0lERXlOelkyTGpFbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q1EwWURRdk5DdzBZTFJnOUdBMExBZ01USWdNVEV1TjlDOElOQ1FMVWxKU1NBeU5kQ1RNdENoSURVM09ERXRPRElnTVRFbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q1EwWURRdk5DdzBZTFJnOUdBMExBZ01UUWdNVEV1TjlDOElOQ1FMVWxKU1NBeU5kQ1RNdENoSURVM09ERXRPRElnTVRFbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzJKaFkydG5jbTkxYm1RNkkwWkdRemREUlR0d1lXUmthVzVuT2pCamJTQTFMalJ3ZENBd1kyMGdOUzQwY0hRN2FHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNBZ1kyeGhjM005SWsxemIwNXZjbTFoYkY5dGNsOWpjM05mWVhSMGNpSStKbXgwTzNOd1lXNGdjM1I1YkdVOUltTnZiRzl5T2lNNVF6QXdNRFk3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVWlQdENRMFlEUXZOQ3cwWUxSZzlHQTBMQWdNVFFnTVRMUXZDRFFrQzFKSU5HQjBZSXowTC9SZ1MvUmdkQy9JRFUzT0RFdE9ESWdNVElzSm14ME95OXpjR0Z1UGlac2REc3ZjRDRtSTNoa093b21iSFE3TDNSa1BpWWplR1E3Q2lac2REc3ZkSEkrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHRpWVdOclozSnZkVzVrT2lOR1JrTTNRMFU3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjam9qT1VNd01EQTJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVklqN1FrTkdBMEx6UXNOR0MwWVBSZ05Dd0lERTJJREV5MEx3ZzBKQXRTU0RSZ2RHQ005Qy8wWUV2MFlIUXZ5QTFOemd4TFRneUlERXlMQ1pzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdZbUZqYTJkeWIzVnVaRG9qUmtaRE4wTkZPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZJemxETURBd05qdHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlNJKzBLalFzdEMxMEx2UXU5QzEwWUFnMEozUW05Q1RJRFF3SU5DZklERXkwTHdnTURuUXN6TFJnU0E0TWpRd0lERXlMREF3Sm14ME95OXpjR0Z1UGlac2REc3ZjRDRtSTNoa093b21iSFE3TDNSa1BpWWplR1E3Q2lac2REc3ZkSEkrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHR3WVdSa2FXNW5PakJqYlNBMUxqUndkQ0F3WTIwZ05TNDBjSFE3YUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM0FnWTJ4aGMzTTlJazF6YjA1dmNtMWhiRjl0Y2w5amMzTmZZWFIwY2lJK0pteDBPM053WVc0Z2MzUjViR1U5SW1OdmJHOXlPbUpzWVdOck8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWSWo3UXFOQ3kwTFhRdTlDNzBMWFJnQ0F5TnlEUW95QXhNdEM4SU5DaE1qVTFJRGd5TkRBZ01USXNNREFtYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlKbWQwT3lZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q2IwTGpSZ2RHQ0lOR0EwTGpSaE5DN0lEZ2dNUzQxMEx3Z050QzhJTkdBMEw3UXZOQ3hJTkdCMFlJejBML1JnUy9SZ2RDL0lEZzFOamdnTmlac2REc3ZjM0JoYmo0bWJIUTdMM0ErSmlONFpEc0tKbXgwT3k5MFpENG1JM2hrT3dvbWJIUTdMM1J5UGlZamVHUTdDaVpzZER0MGNpQnpkSGxzWlQwaWFHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNSa0lIZHBaSFJvUFNJeU9EVWlJRzV2ZDNKaGNEMGlJaUIyWVd4cFoyNDlJbUp2ZEhSdmJTSWdjM1I1YkdVOUluZHBaSFJvT2pJeE5DNHdjSFE3WW1GamEyZHliM1Z1WkRvalJrWkROME5GTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2SXpsRE1EQXdOanR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZTSSswS0xSZ05HRDBMSFFzQ0RRdjlHQTBMN1JoTkM0MEx2UmpOQzkwTERSanlBeE1qQWdNVEl3SURZbUkzaGtPd29tYkhRN2MzQmhiaUJqYkdGemN6MGlhbk10Y0dodmJtVXRiblZ0WW1WeUlqNDROak01THpNd01qUTFKbXgwT3k5emNHRnVQaVpzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdjR0ZrWkdsdVp6b3dZMjBnTlM0MGNIUWdNR050SURVdU5IQjBPMmhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdHdJR05zWVhOelBTSk5jMjlPYjNKdFlXeGZiWEpmWTNOelgyRjBkSElpUGlac2REdHpjR0Z1SUhOMGVXeGxQU0pqYjJ4dmNqcGliR0ZqYXp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEtMUmdOR0QwTEhRc0NEUXY5R0EwTDdSaE5DNDBMdlJqTkM5MExEUmp5WWplR1E3Q2lac2REdHpjR0Z1SUdOc1lYTnpQU0pxY3kxd2FHOXVaUzF1ZFcxaVpYSWlQamd3SURnd0lEUWdPRFl6T1M4ek1ESTBOU1pzZERzdmMzQmhiajRtYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHQwWkNCM2FXUjBhRDBpTWpnMUlpQnViM2R5WVhBOUlpSWdkbUZzYVdkdVBTSmliM1IwYjIwaUlITjBlV3hsUFNKM2FXUjBhRG95TVRRdU1IQjBPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZZbXhoWTJzN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDaTBZRFJnOUN4MExBZzBML1JnTkMrMFlUUXVOQzcwWXpRdmRDdzBZOG1JM2hrT3dvbWJIUTdjM0JoYmlCamJHRnpjejBpYW5NdGNHaHZibVV0Ym5WdFltVnlJajQ0TUNBME1DQTBJRGcyTkRVdk16QXlORFVtYkhRN0wzTndZVzQrSm14ME95OXpjR0Z1UGlac2REc3ZjRDRtSTNoa093b21iSFE3TDNSa1BpWWplR1E3Q2lac2REc3ZkSEkrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHR3WVdSa2FXNW5PakJqYlNBMUxqUndkQ0F3WTIwZ05TNDBjSFE3YUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM0FnWTJ4aGMzTTlJazF6YjA1dmNtMWhiRjl0Y2w5amMzTmZZWFIwY2lJK0pteDBPM053WVc0Z2MzUjViR1U5SW1OdmJHOXlPbUpzWVdOck8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWSWo3UW90R0EwWVBRc2RDd0lOQy8wWURRdnRHRTBMalF1OUdNMEwzUXNOR1BJRFl3SURRd0lETW1JM2hrT3dvbWJIUTdjM0JoYmlCamJHRnpjejBpYW5NdGNHaHZibVV0Ym5WdFltVnlJajQ0TmpRMUx6TXdNalExSm14ME95OXpjR0Z1UGlac2REc3ZjM0JoYmo0bWJIUTdMM0ErSmlONFpEc0tKbXgwT3k5MFpENG1JM2hrT3dvbWJIUTdMM1J5UGlZamVHUTdDaVpzZER0MGNpQnpkSGxzWlQwaWFHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNSa0lIZHBaSFJvUFNJeU9EVWlJRzV2ZDNKaGNEMGlJaUIyWVd4cFoyNDlJbUp2ZEhSdmJTSWdjM1I1YkdVOUluZHBaSFJvT2pJeE5DNHdjSFE3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjanBpYkdGamF6dHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlNJKzBLTFJnTkdEMExIUXNDRFF2OUdBMEw3UmhOQzQwTHZSak5DOTBMRFJqeUF4TURBZ01UQXdJRFltSTNoa093b21iSFE3YzNCaGJpQmpiR0Z6Y3owaWFuTXRjR2h2Ym1VdGJuVnRZbVZ5SWo0NE5qTTVMek13TWpRMUpteDBPeTl6Y0dGdVBpWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN1ltRmphMmR5YjNWdVpEb2pSa1pETjBORk8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNkl6bERNREF3Tmp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEpEUmdOQzgwTERSZ3RHRDBZRFFzQ0F4T0NBeE1TNDMwTHdnMEpBMU1EQWcwS0VnTXpRd01qZ3RNVFlnTVRFc056QW1iSFE3TDNOd1lXNCtKbXgwT3k5d1BpWWplR1E3Q2lac2REc3ZkR1ErSmlONFpEc0tKbXgwT3k5MGNqNG1JM2hrT3dvbWJIUTdkSElnYzNSNWJHVTlJbWhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdDBaQ0IzYVdSMGFEMGlNamcxSWlCdWIzZHlZWEE5SWlJZ2RtRnNhV2R1UFNKaWIzUjBiMjBpSUhOMGVXeGxQU0ozYVdSMGFEb3lNVFF1TUhCME8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNllteGhZMnM3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVWlQdENRMFlEUXZOQ3cwWUxSZzlHQTBMQWdNVEFnTVRFdU45QzhJTkNRTWpRd0lETTBNREk0TFRFMklERXhMRGN3Sm14ME95OXpjR0Z1UGlac2REc3ZjRDRtSTNoa093b21iSFE3TDNSa1BpWWplR1E3Q2lac2REc3ZkSEkrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHR3WVdSa2FXNW5PakJqYlNBMUxqUndkQ0F3WTIwZ05TNDBjSFE3YUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM0FnWTJ4aGMzTTlJazF6YjA1dmNtMWhiRjl0Y2w5amMzTmZZWFIwY2lJK0pteDBPM053WVc0Z2MzUjViR1U5SW1OdmJHOXlPbUpzWVdOck8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWSWo3UW45R0EwTDdRc3RDKzBMdlF2dEM2MExBZ1pEWXVNQ0RRdk5DKzBZTFF1dEM0SU5DOUw5R0RJTkdDTDlDOUlOQ2UwS1lnTXpJNE1pWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN1ltRmphMmR5YjNWdVpEb2pSa1pETjBORk8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNkl6bERNREF3Tmp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEovUmdOQyswTExRdnRDNzBMN1F1dEN3SUdReUxqY2cwTEhSZzlHRjBZTFFzQ0RRa3RDZ0xURWcwS0xRb3lac2REc3ZjM0JoYmo0bWJIUTdMM0ErSmlONFpEc0tKbXgwT3k5MFpENG1JM2hrT3dvbWJIUTdMM1J5UGlZamVHUTdDaVpzZER0MGNpQnpkSGxzWlQwaWFHVnBaMmgwT2pFMUxqQndkQ0ltWjNRN0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN2NHRmtaR2x1Wnpvd1kyMGdOUzQwY0hRZ01HTnRJRFV1TkhCME8yaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0d0lHTnNZWE56UFNKTmMyOU9iM0p0WVd4ZmJYSmZZM056WDJGMGRISWlQaVpzZER0emNHRnVJSE4wZVd4bFBTSmpiMnh2Y2pwaWJHRmphenR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZTSSswSi9SZ05DKzBZVFF1TkM3MFl3ZzBKUFFtdENiSU5DZjBKOGdOakFnTWpjZ01DNDJJRFBRdkNEUXJURXhPQ0RRbjlDdElETXNNREFtYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHQwWkNCM2FXUjBhRDBpTWpnMUlpQnViM2R5WVhBOUlpSWdkbUZzYVdkdVBTSmliM1IwYjIwaUlITjBlV3hsUFNKM2FXUjBhRG95TVRRdU1IQjBPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZZbXhoWTJzN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDZjBZRFF2dEdFMExqUXU5R01JTkNUMEpyUW15RFFuOUNmSURZd0lESTNJREF1TkRVZ005QzhJTkN0TVRFNElETXNNREFtYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHQwWkNCM2FXUjBhRDBpTWpnMUlpQnViM2R5WVhBOUlpSWdkbUZzYVdkdVBTSmliM1IwYjIwaUlITjBlV3hsUFNKM2FXUjBhRG95TVRRdU1IQjBPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZZbXhoWTJzN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDYjBMalJnZEdDSU5DVEw5Q2FJRFFnTVM0MTBMd2dNOUM4SU5HQjBZSXowTC9SZ1RVdjBZSFF2elVnTVRRMk16Y2cwS1FnTXl3bWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q2IwTGpSZ2RHQ0lOQ2QwSnZRa3lBMUlERXVOZEM4SURiUXZDQXdPZEN6TXRHQkxURTFJREU1TWpneElOQ2tJRFlzTURBbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q2IwTGpSZ2RHQ0lOQ1RMOUNhSURVZ01TNDEwTHdnTnRDOElOR0IwWUl6MEwvUmdUVXYwWUhRdnpVZ01UUTJNemNnMEtRZ05pd21iSFE3TDNOd1lXNCtKbXgwT3k5d1BpWWplR1E3Q2lac2REc3ZkR1ErSmlONFpEc0tKbXgwT3k5MGNqNG1JM2hrT3dvbWJIUTdkSElnYzNSNWJHVTlJbWhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdDBaQ0IzYVdSMGFEMGlNamcxSWlCdWIzZHlZWEE5SWlJZ2RtRnNhV2R1UFNKaWIzUjBiMjBpSUhOMGVXeGxQU0ozYVdSMGFEb3lNVFF1TUhCME8ySmhZMnRuY205MWJtUTZJMFpHUXpkRFJUdHdZV1JrYVc1bk9qQmpiU0ExTGpSd2RDQXdZMjBnTlM0MGNIUTdhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zQWdZMnhoYzNNOUlrMXpiMDV2Y20xaGJGOXRjbDlqYzNOZllYUjBjaUkrSm14ME8zTndZVzRnYzNSNWJHVTlJbU52Ykc5eU9pTTVRekF3TURZN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUGtjdDBML1F1OUN3MEwzUXV0Q3dJTkNRMExyUXN0Q3cwWUhRdU5HQjBZTFF0ZEM4SURMUXZDRFJnZEdDMExEUXU5R01JRkpTTWpBZzBMSFF0ZEM3MFl2UXVTWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN1ltRmphMmR5YjNWdVpEb2pSa1pETjBORk8zQmhaR1JwYm1jNk1HTnRJRFV1TkhCMElEQmpiU0ExTGpSd2REdG9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2NDQmpiR0Z6Y3owaVRYTnZUbTl5YldGc1gyMXlYMk56YzE5aGRIUnlJajRtYkhRN2MzQmhiaUJ6ZEhsc1pUMGlZMjlzYjNJNkl6bERNREF3Tmp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEp2UXVOR0IwWUlnMEozUW05Q1RJRFlnTXRDOElEYlF2Q0F3T2RDek10R0JJREU1TWpneElOQ2tJRFlzTURBbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzJKaFkydG5jbTkxYm1RNkkwWkdRemREUlR0d1lXUmthVzVuT2pCamJTQTFMalJ3ZENBd1kyMGdOUzQwY0hRN2FHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNBZ1kyeGhjM005SWsxemIwNXZjbTFoYkY5dGNsOWpjM05mWVhSMGNpSStKbXgwTzNOd1lXNGdjM1I1YkdVOUltTnZiRzl5T2lNNVF6QXdNRFk3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVWlQdENiMExqUmdkR0NJTkNlMEtZZ01TNDFJTkM5MExYUXV0QyswTDNRdE5DNDBZYlF1TkdQSm14ME95OXpjR0Z1UGlac2REc3ZjRDRtSTNoa093b21iSFE3TDNSa1BpWWplR1E3Q2lac2REc3ZkSEkrSmlONFpEc0tKbXgwTzNSeUlITjBlV3hsUFNKb1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3ZEdRZ2QybGtkR2c5SWpJNE5TSWdibTkzY21Gd1BTSWlJSFpoYkdsbmJqMGlZbTkwZEc5dElpQnpkSGxzWlQwaWQybGtkR2c2TWpFMExqQndkRHRpWVdOclozSnZkVzVrT2lOR1JrTTNRMFU3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjam9qT1VNd01EQTJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVklqNUhMZEMvMEx2UXNOQzkwTHJRc0NEUWtOQzYwTExRc05HQjBMalJnZEdDMExYUXZDQXkwTHdnMFlIUmd0Q3cwTHZSakNCU1VqSXdJTkN4MExYUXU5R0wwTGttYkhRN0wzTndZVzQrSm14ME95OXdQaVlqZUdRN0NpWnNkRHN2ZEdRK0ppTjRaRHNLSm14ME95OTBjajRtSTNoa093b21iSFE3ZEhJZ2MzUjViR1U5SW1obGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHQwWkNCM2FXUjBhRDBpTWpnMUlpQnViM2R5WVhBOUlpSWdkbUZzYVdkdVBTSmliM1IwYjIwaUlITjBlV3hsUFNKM2FXUjBhRG95TVRRdU1IQjBPM0JoWkdScGJtYzZNR050SURVdU5IQjBJREJqYlNBMUxqUndkRHRvWldsbmFIUTZNVFV1TUhCMElqNG1JM2hrT3dvbWJIUTdjQ0JqYkdGemN6MGlUWE52VG05eWJXRnNYMjF5WDJOemMxOWhkSFJ5SWo0bWJIUTdjM0JoYmlCemRIbHNaVDBpWTI5c2IzSTZZbXhoWTJzN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFVpUHRDYjBMalJnZEdDSU5HQTBMalJoTkM3SURNZ01TNHlOZEM4SURJdU5kQzhJTkdIMExYUmg5QzEwTExRdU5HRzBMQWcwWUhRdjlDMTBZYlJnTkN3MFlIUXVpWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN2NHRmtaR2x1Wnpvd1kyMGdOUzQwY0hRZ01HTnRJRFV1TkhCME8yaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0d0lHTnNZWE56UFNKTmMyOU9iM0p0WVd4ZmJYSmZZM056WDJGMGRISWlQaVpzZER0emNHRnVJSE4wZVd4bFBTSmpiMnh2Y2pwaWJHRmphenR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZTSSswSnZRdU5HQjBZSWcwWURRdU5HRTBMc2dOQ0F4TGpYUXZDQTIwTHdnMFlmUXRkR0gwTFhRc3RDNDBZYlFzQ0RSZ2RHQ005Qy8wWUV2MFlIUXZ5QTROU1pzZERzdmMzQmhiajRtYkhRN0wzQStKaU40WkRzS0pteDBPeTkwWkQ0bUkzaGtPd29tYkhRN0wzUnlQaVlqZUdRN0NpWnNkRHQwY2lCemRIbHNaVDBpYUdWcFoyaDBPakUxTGpCd2RDSStKaU40WkRzS0pteDBPM1JrSUhkcFpIUm9QU0l5T0RVaUlHNXZkM0poY0QwaUlpQjJZV3hwWjI0OUltSnZkSFJ2YlNJZ2MzUjViR1U5SW5kcFpIUm9Pakl4TkM0d2NIUTdjR0ZrWkdsdVp6b3dZMjBnTlM0MGNIUWdNR050SURVdU5IQjBPMmhsYVdkb2REb3hOUzR3Y0hRaVBpWWplR1E3Q2lac2REdHdJR05zWVhOelBTSk5jMjlPYjNKdFlXeGZiWEpmWTNOelgyRjBkSElpUGlac2REdHpjR0Z1SUhOMGVXeGxQU0pqYjJ4dmNqcGliR0ZqYXp0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWU0krMEp2UXVOR0IwWUlnMEpNdjBKb2dOQ0F4TGpYUXZDQTIwTHdnMFlIUmdqUFF2OUdCTlMvUmdkQy9OU0F4TkRZek55RFFwQ0EyTENac2REc3ZjM0JoYmo0bWJIUTdMM0ErSmlONFpEc0tKbXgwT3k5MFpENG1JM2hrT3dvbWJIUTdMM1J5UGlZamVHUTdDaVpzZER0MGNpQnpkSGxzWlQwaWFHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNSa0lIZHBaSFJvUFNJeU9EVWlJRzV2ZDNKaGNEMGlJaUIyWVd4cFoyNDlJbUp2ZEhSdmJTSWdjM1I1YkdVOUluZHBaSFJvT2pJeE5DNHdjSFE3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjanBpYkdGamF6dHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlNJKzBLalFzdEMxMEx2UXU5QzEwWUFnT0NEUW55QXhNdEM4SU5HQjBZSXowTC9SZ1RVdjBZSFF2elVnT0RJME1DQXhNaXd3TUNac2REc3ZjM0JoYmo0bWJIUTdMM0ErSmlONFpEc0tKbXgwT3k5MFpENG1JM2hrT3dvbWJIUTdMM1J5UGlZamVHUTdDaVpzZER0MGNpQnpkSGxzWlQwaWFHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNSa0lIZHBaSFJvUFNJeU9EVWlJRzV2ZDNKaGNEMGlJaUIyWVd4cFoyNDlJbUp2ZEhSdmJTSWdjM1I1YkdVOUluZHBaSFJvT2pJeE5DNHdjSFE3Y0dGa1pHbHVaem93WTIwZ05TNDBjSFFnTUdOdElEVXVOSEIwTzJobGFXZG9kRG94TlM0d2NIUWlQaVlqZUdRN0NpWnNkRHR3SUdOc1lYTnpQU0pOYzI5T2IzSnRZV3hmYlhKZlkzTnpYMkYwZEhJaVBpWnNkRHR6Y0dGdUlITjBlV3hsUFNKamIyeHZjanBpYkdGamF6dHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlNJKzBLalFzdEMxMEx2UXU5QzEwWUFnTVRZZzBKOGdNVExRdkNEUmdkR0NNOUMvMFlFMUw5R0IwTDgxSURneU5EQWdNVElzTURBbWJIUTdMM053WVc0K0pteDBPeTl3UGlZamVHUTdDaVpzZERzdmRHUStKaU40WkRzS0pteDBPeTkwY2o0bUkzaGtPd29tYkhRN2RISWdjM1I1YkdVOUltaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0MFpDQjNhV1IwYUQwaU1qZzFJaUJ1YjNkeVlYQTlJaUlnZG1Gc2FXZHVQU0ppYjNSMGIyMGlJSE4wZVd4bFBTSjNhV1IwYURveU1UUXVNSEIwTzNCaFpHUnBibWM2TUdOdElEVXVOSEIwSURCamJTQTFMalJ3ZER0b1pXbG5hSFE2TVRVdU1IQjBJajRtSTNoa093b21iSFE3Y0NCamJHRnpjejBpVFhOdlRtOXliV0ZzWDIxeVgyTnpjMTloZEhSeUlqNG1iSFE3YzNCaGJpQnpkSGxzWlQwaVkyOXNiM0k2WW14aFkyczdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxVaVB0Q2owTFBRdnRDNzBMN1F1aUEwTUNBME1DQXpJREV5MEx3ZzBZSFJnalBRdjlHQk5TL1JnZEMvTlNBNE5UQTVJREV5TERBd0pteDBPeTl6Y0dGdVBpWnNkRHN2Y0Q0bUkzaGtPd29tYkhRN0wzUmtQaVlqZUdRN0NpWnNkRHN2ZEhJK0ppTjRaRHNLSm14ME8zUnlJSE4wZVd4bFBTSm9aV2xuYUhRNk1UVXVNSEIwSWo0bUkzaGtPd29tYkhRN2RHUWdkMmxrZEdnOUlqSTROU0lnYm05M2NtRndQU0lpSUhaaGJHbG5iajBpWW05MGRHOXRJaUJ6ZEhsc1pUMGlkMmxrZEdnNk1qRTBMakJ3ZER0d1lXUmthVzVuT2pCamJTQTFMalJ3ZENBd1kyMGdOUzQwY0hRN2FHVnBaMmgwT2pFMUxqQndkQ0krSmlONFpEc0tKbXgwTzNBZ1kyeGhjM005SWsxemIwNXZjbTFoYkY5dGNsOWpjM05mWVhSMGNpSStKbXgwTzNOd1lXNGdjM1I1YkdVOUltTnZiRzl5T21Kc1lXTnJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVklqN1FvOUN6MEw3UXU5QyswTG9nTlRBZ05UQWdOU0F4TXRDOElOR0IwWUl6MEwvUmdUVXYwWUhRdnpVZ09EVXdPU0F4TWl3d01DWnNkRHN2YzNCaGJqNG1iSFE3TDNBK0ppTjRaRHNLSm14ME95OTBaRDRtSTNoa093b21iSFE3TDNSeVBpWWplR1E3Q2lac2REdDBjaUJ6ZEhsc1pUMGlhR1ZwWjJoME9qRTFMakJ3ZENJK0ppTjRaRHNLSm14ME8zUmtJSGRwWkhSb1BTSXlPRFVpSUc1dmQzSmhjRDBpSWlCMllXeHBaMjQ5SW1KdmRIUnZiU0lnYzNSNWJHVTlJbmRwWkhSb09qSXhOQzR3Y0hRN2NHRmtaR2x1Wnpvd1kyMGdOUzQwY0hRZ01HTnRJRFV1TkhCME8yaGxhV2RvZERveE5TNHdjSFFpUGlZamVHUTdDaVpzZER0d0lHTnNZWE56UFNKTmMyOU9iM0p0WVd4ZmJYSmZZM056WDJGMGRISWlQaVpzZER0emNHRnVJSE4wZVd4bFBTSmpiMnh2Y2pwaWJHRmphenR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZTSSswS1BRczlDKzBMdlF2dEM2SURjMUlEYzFJRFlnTVRMUXZDRFJnZEdDTTlDLzBZRTFMOUdCMEw4MUlEZzFNRGtnTVRJc01EQW1iSFE3TDNOd1lXNCtKbXgwT3k5d1BpWWplR1E3Q2lac2REc3ZkR1ErSmlONFpEc0tKbXgwT3k5MGNqNG1JM2hrT3dvbWJIUTdMM1JpYjJSNVBpWWplR1E3Q2lac2REc3ZkR0ZpYkdVK0ppTjRaRHNLSm14ME8zQWdZMnhoYzNNOUlrMXpiMDV2Y20xaGJGOXRjbDlqYzNOZllYUjBjaUkrSm1GdGNEdHVZbk53T3lac2REc3ZjRDRtSTNoa093b21iSFE3TDJScGRqNG1JM2hrT3dvbWJIUTdjQ0J6ZEhsc1pUMGlZMjlzYjNJNkl6TmhOelZqTkR0bWIyNTBPamx3ZENCQmNtbGhiQ0krMEtQUXN0Q3cwTGJRc05DMTBMelJpOUMxSU5DNjBMN1F1OUM3MExYUXM5QzRJTkM0SU5DLzBMRFJnTkdDMEwzUXRkR0EwWXNzSm14ME95OXdQaVlqZUdRN0NpWnNkRHR3SUhOMGVXeGxQU0pqYjJ4dmNqb2pNMkUzTldNME8yWnZiblE2T1hCMElFRnlhV0ZzSWo3UW5kQ3cwWWpRc0NEUW10QyswTHpRdjlDdzBMM1F1TkdQSU5DLzBZRFF1TkMwMExYUmdOQzIwTGpRc3RDdzBMWFJndEdCMFk4ZzBZM1JndEM0MFlmUXRkR0IwTHJRdU5HRklOQy8wWURRdU5DOTBZYlF1TkMvMEw3UXNpRFFzdEMxMExUUXRkQzkwTGpSanlEUXNkQzQwTGZRdmRDMTBZSFFzQ0RRdUNEUXROQzEwTHZRc05DMTBZSWcwTExSZ2RDMUlOQzAwTHZSanlEUmd0QyswTFBRdml3ZzBZZlJndEMrMExIUml5RFFzdEMzMExEUXVOQzgwTDdRdnRHQzBMM1F2dEdJMExYUXZkQzQwWThnMFlFZzBMM1FzTkdJMExqUXZOQzRJTkMvMExEUmdOR0MwTDNRdGRHQTBMRFF2TkM0SU5HQjBZTFJnTkMrMExqUXU5QzQwWUhSakNEUXZkQ3dJTkMvMFlEUXVOQzkwWWJRdU5DLzBMRFJoU0RRdnRHQzBMclJnTkdMMFlMUXZ0R0IwWUxRdUNEUXVDRFF2OUdBMEw3UXQ5R0EwTERSaDlDOTBMN1JnZEdDMExndUlOQ2YwTDdSamRHQzBMN1F2TkdESU5DLzBZRFF2dEdCMExqUXZDRFFrdEN3MFlFZzBZSFF2dEMrMExIUmlkQ3cwWUxSakNEUXZkQ3cwTHdnMEw3UXNkQytJTkN5MFlIUXRkR0ZKaU40WkRzS0lOQzkwTFhRczlDdzBZTFF1TkN5MEwzUmk5R0ZJTkdFMExEUXV0R0MwTERSaFNEUXN0QytJTkN5MExmUXNOQzQwTHpRdnRDKzBZTFF2ZEMrMFlqUXRkQzkwTGpSajlHRklOR0JJTkM5MExEUmlOQzEwTGtnMExyUXZ0QzgwTC9Rc05DOTBMalF0ZEM1SU5DLzBMNGcwTERRdE5HQTBMWFJnZEdESUNac2REdGhJSE4wZVd4bFBTSmpiMnh2Y2pvak0yRTNOV00wT3lJZ2FISmxaajBpTHk5bExtMWhhV3d1Y25VdlkyOXRjRzl6WlM4L2JXRnBiSFJ2UFcxaGFXeDBieVV6WVdSdmRtVnlhV1ZBYzJOdExuSjFJaUIwWVhKblpYUTlJbDlpYkdGdWF5SWdjbVZzUFNJZ2JtOXZjR1Z1WlhJZ2JtOXlaV1psY25KbGNpSStKaU40WkRzS1pHOTJaWEpwWlVCelkyMHVjblVtYkhRN0wyRStMaURRa3RHQjBZOGcwTGpRdmRHRTBMN1JnTkM4MExEUmh0QzQwWThnMEwvUXZ0R0IwWUxSZzlDLzBMRFF0ZEdDSU5DeUlOQzkwTFhRdDlDdzBMTFF1TkdCMExqUXZOR0QwWTRnMFlIUXU5R0QwTGJRc2RHRElOQ3kwTDNSZzlHQzBZRFF0ZEM5MEwzUXRkQ3owTDRnMExEUmc5QzAwTGpSZ3RDd0xpWnNkRHN2Y0Q0bUkzaGtPd29tYkhRN2NDQnpkSGxzWlQwaVkyOXNiM0k2SXpOaE56VmpORHRtYjI1ME9qbHdkQ0JCY21saGJDSSswSi9SZ05DMTBZTFF0ZEM5MExmUXVOQzRJTkMvMEw0ZzBMclFzTkdIMExYUmdkR0MwTExSZ3lEUXZ0Q3gwWUhRdTlHRDBMYlF1TkN5MExEUXZkQzQwWThnMExqUXU5QzRJTkdDMEw3UXN0Q3cwWURRc0NEUXY5R0EwTGpRdmRDNDBMelFzTkdPMFlMUmdkR1BJTkM5MExBZzBZTFF0ZEM3MExYUmhOQyswTDBnMExQUXZ0R0EwWS9SaDlDMTBMa2cwTHZRdU5DOTBMalF1Q1lqZUdRN0NpWnNkRHQxUGlac2REdHpjR0Z1SUdOc1lYTnpQU0pxY3kxd2FHOXVaUzF1ZFcxaVpYSWlQamd0T0RBd0xUY3dNREF0TVRJekpteDBPeTl6Y0dGdVBpWnNkRHN2ZFQ0dUlOQ1gwTExRdnRDOTBMclF1Q0RRdjlDK0lOQ2cwTDdSZ2RHQjBMalF1Q0RRc2RDMTBZSFF2OUM3MExEUmd0QzkwTDRtYkhRN0wzQStKaU40WkRzS0pteDBPeTlrYVhZK0ppTjRaRHNLSm14ME95OWthWFkrSmlONFpEc0tKbXgwT3k5a2FYWStKaU40WkRzS0pteDBPeTlrYVhZK0ppTjRaRHNLSm14ME95OWliRzlqYTNGMWIzUmxQaVlqZUdRN0NpWnNkRHN2WkdsMlBpWWplR1E3Q2lac2REc3ZZbTlrZVQ0bUkzaGtPd29tYkhRN0wyaDBiV3crSmlONFpEc0tQQzltYVd4bFEyOXVkR1Z1ZEQ0OEwycHpiMjVQWW1wbFkzUStQQzl6YjJGd1pXNTJPa0p2WkhrK1BDOXpiMkZ3Wlc1Mk9rVnVkbVZzYjNCbFBnPT0=')
    # order_rec.save_truth_test(content='{"req_number": "ca885b6d-17b7-4d01-bcfa-8ae880437bae", "mail_code": "0057653611", "user": "SHARIPOVDI", "positions": [{"position_id": "0", "true_material": "000000000000074902", "true_ei": "", "true_value": "3.000", "spec_mat": ""}, {"position_id": "1", "true_material": "000000000000008208", "true_ei": "", "true_value": "15.000", "spec_mat": ""}, {"position_id": "2", "true_material": "000000000000099427", "true_ei": "", "true_value": "5.000", "spec_mat": ""}, {"position_id": "3", "true_material": "000000000000116100", "true_ei": "", "true_value": "30.000", "spec_mat": ""}, {"position_id": "4", "true_material": "000000003000005659", "true_ei": "ШТ", "true_value": "15.000", "spec_mat": ""}, {"position_id": "5", "true_material": "000000000000016617", "true_ei": "ШТ", "true_value": "1.000", "spec_mat": ""}]}')