import csv
import time
import os
import pickle
import numpy as np
import faiss
import json
from concurrent.futures import ThreadPoolExecutor, as_completed

from order_recognition.core.hash2text import text_from_hash
from langchain.docstore.document import Document
from langchain_community.docstore.in_memory import InMemoryDocstore
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from yandex_cloud_ml_sdk import YCloudML
from yandexgpt import custom_yandex_gpt
from order_recognition.confs import config

class MaterialSelector:
    def __init__(self, csv_path: str, folder_id: str,
                 embedding_cache_file: str = "order_recognition/data/embeddings_cache.pkl",
                 chunk_size: int = 1, chunk_overlap: int = 0,
                 model_name: str = "cointegrated/rubert-tiny2"):
        """
        Инициализация:
          - Загружает материалы из CSV‑файла с объединением нескольких строк в один документ.
          - Создает FAISS‑индекс с использованием эмбеддингов модели cointegrated/rubert-tiny2.
          - Сохраняет/подгружает эмбеддинги для документов.
          - Инициализирует YandexGPT для подбора лучших материалов.
          - Инициализирует объект для извлечения позиций из чистого письма.
        
        Параметры:
          csv_path: путь к CSV‑файлу с материалами.
          folder_id: идентификатор каталога для YandexCloud.
          embedding_cache_file: путь к файлу кэша эмбеддингов.
          chunk_size: число строк, объединяемых в один документ.
          chunk_overlap: количество строк перекрытия между соседними документами.
          model_name: имя модели эмбеддингов (по умолчанию "cointegrated/rubert-tiny2").
        """
        self.csv_path = csv_path
        self.folder_id = folder_id
        self.embedding_cache_file = embedding_cache_file
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap

        # Объект для извлечения позиций из письма
        self.position_extractor = custom_yandex_gpt()
        self.position_extractor.update_token()
        self.iam_token = self.position_extractor.headers["Authorization"][7:]

        # Инструкция для системного промпта
        with open("order_recognition/confs/second_gpt_instruct.txt", encoding="utf-8") as f:
            self.system_instruct = f.read().strip()

        # Загружаем материалы
        self.materials = self.load_materials(self.csv_path)

        # Инициализируем эмбеддинги
        self.embeddings = HuggingFaceEmbeddings(model_name=model_name)

        # Загружаем кэш эмбеддингов (если файл существует)
        if os.path.exists(self.embedding_cache_file):
            print("Загружаем кэш эмбеддингов...")
            with open(self.embedding_cache_file, "rb") as f:
                cache = pickle.load(f)
        else:
            print("Кэш эмбеддингов не найден, вычисляем эмбеддинги...")
            cache = {}

        # Вычисляем эмбеддинги для каждого документа (с использованием кэша)
        computed_embeddings = []
        for ind, doc in enumerate(self.materials):
            key = doc.page_content
            if key in cache:
                emb = cache[key]
            else:
                if ind%500==0:
                    print(ind)
                emb = self.embeddings.embed_query(key)
                cache[key] = emb
            computed_embeddings.append(emb)
        print("Эмбэддинги загружены!")

        # Сохраняем обновленный кэш эмбеддингов
        with open(self.embedding_cache_file, "wb") as f:
            pickle.dump(cache, f)

        # Создаём FAISS-индекс
        print("Создаём FAISS-индекс...")
        if computed_embeddings:
            dimension = len(computed_embeddings[0])
            index = faiss.IndexFlatL2(dimension)
            emb_matrix = np.array(computed_embeddings).astype("float32")
            index.add(emb_matrix)
        else:
            raise ValueError("Нет эмбеддингов для создания FAISS‑индекса.")

        # Формируем docstore: ключ – строковый индекс, значение – документ
        docstore = InMemoryDocstore({str(i): doc for i, doc in enumerate(self.materials)})

        # Создаем index_to_docstore_id, сопоставляющий индексы FAISS с идентификаторами документов
        index_to_docstore_id = {i: str(i) for i in range(len(self.materials))}
        self.vectorstore = FAISS(
            embedding_function=self.embeddings,
            index=index,
            docstore=docstore,
            index_to_docstore_id=index_to_docstore_id
        )

        # Модель для уточняющего подбора
        print("Инициализируем модель...")
        self.sdk = YCloudML(folder_id=self.folder_id, auth=self.iam_token)
        self.model = self.sdk.models.completions("yandexgpt").configure(temperature=0.1)

    def load_materials(self, csv_path: str):
        """
        Загружает материалы из CSV‑файла и группирует строки в документы.
        Каждый документ формируется из chunk_size строк с перекрытием chunk_overlap.
        
        При работе с файлом, содержащим более 100 000 записей, группировка строк позволяет
        сократить количество документов для индексирования, что может ускорить поиск и снизить
        нагрузку на память. Однако если требуется высокая детализация поиска по отдельным материалам,
        имеет смысл оставлять одну строку как отдельный документ.
        
        Возвращает список объектов Document.
        """
        with open(csv_path, encoding="utf-8") as f:
            reader = list(csv.DictReader(f))

        documents = []
        step = self.chunk_size - self.chunk_overlap
        for i in range(0, len(reader), step):
            chunk = reader[i: i + self.chunk_size]
            if not chunk:
                break
            lines = []
            material_ids = []
            for row in chunk:
                # Формируем строку: номер материала и полное наименование
                line = f"{row['Полное наименование материала']}"
                lines.append(line)
                material_ids.append(row['Материал'])
            content = "\n".join(lines)
            documents.append(Document(page_content=content, metadata={"Материалы": material_ids}))
        return documents

    def _process_single_position(self, pos_text: str):
        """
        Вспомогательный метод, который обрабатывает одну позицию:
          1. Ищет похожие документы (k=20).
          2. Формирует промпт для модели.
          3. Запрашивает модель и возвращает (pos_text, результат).
        """
        # Шаг 1. Ищем похожие документы
        similar_docs = self.vectorstore.similarity_search(pos_text, k=20)
        print(f"СТРОКИ ДЛЯ {pos_text}:", similar_docs)
        # Собираем номера материалов
        materials_list = [
            "\n".join([f"{m_id}" for m_id in doc.metadata["Материалы"]])
            for doc in similar_docs
        ]

        # Шаг 2. Формируем промпты
        system_message = {"role": "system", "text": self.system_instruct}
        user_message = {
            "role": "user",
            "text": f"Найди для этого текста: {pos_text}\n 5 максимально похожих строк в этих документах:\n" + "\n".join(materials_list)
        }

        # Шаг 3. Запрашиваем модель
        response = self.model.run([system_message, user_message])
        result_text = response[0].text.strip()
        return pos_text, result_text

    def process_email(self, email_content: str):
        """
        Обрабатывает письмо от клиента:
          1. Извлекает позиции.
          2. Запускает каждую позицию на обработку в отдельном потоке (ThreadPool).
          3. Собирает результаты в общий словарь.
        """
        print("Начали искать позиции в письме...")
        positions = self.position_extractor.big_mail(email_content)  # [(pos_text, ...), ...]

        results = {}
        # Запускаем пул потоков
        with ThreadPoolExecutor(max_workers=5) as executor:
            # Создаём задания для каждого pos_text
            future_to_position = {
                executor.submit(self._process_single_position, pos_tuple[0]): pos_tuple[0]
                for pos_tuple in positions
            }

            # Ожидаем завершения
            for future in as_completed(future_to_position):
                pos_text = future_to_position[future]
                try:
                    # Получаем результат
                    key, value = future.result()
                    results[key] = value
                except Exception as e:
                    # В случае ошибки
                    results[pos_text] = f"Ошибка при обработке: {e}"

        return results

if __name__ == '__main__':
    csv_path = "order_recognition/data/mats.csv"
    folder_id = config.xfolderid  # замените на ваш folder_id
    selector = MaterialSelector(csv_path, folder_id)

    email_content = (
        "Здравствуйте, уголок 35x4 ст3пс - 1.3 тн, арматура арматуру 12 480м по 6м., "
        "швеллер 8п-5 штук по 12 метров. Напишите о возможности доставки, спасибо."
    )

    # print("Начало обработки...")
    # start_time = time.time()
    # results = selector.process_email(email_content)
    # end_time = time.time()
    # elapsed_time = end_time - start_time
    # print(f"Время обработки письма: {elapsed_time:.2f} секунд")

    # print("Итоговые результаты подбора материалов:")
    # for pos, res in results.items():
    #     print(f"Позиция: {pos} -> Материалы: {res}")

    hash = "ZXlKaWRXTnJaWFJPWVcxbElqb2lZM0p0TFdWdFlXbHNJaXdpYjJKcVpXTjBUbUZ0WlNJNkltMXpaMTg0WW1WbE1HVmtNek01T1RBeE9EazVaREkyT1dKaU1qTmpaRFUzTVdVM015SXNJbVpwYkdWRGIyNTBaVzUwSWpvaVBHaDBiV3dnZUcxc2JuTTZkajFjSW5WeWJqcHpZMmhsYldGekxXMXBZM0p2YzI5bWRDMWpiMjA2ZG0xc1hDSWdlRzFzYm5NNmJ6MWNJblZ5YmpwelkyaGxiV0Z6TFcxcFkzSnZjMjltZEMxamIyMDZiMlptYVdObE9tOW1abWxqWlZ3aUlIaHRiRzV6T25jOVhDSjFjbTQ2YzJOb1pXMWhjeTF0YVdOeWIzTnZablF0WTI5dE9tOW1abWxqWlRwM2IzSmtYQ0lnZUcxc2JuTTZlRDFjSW5WeWJqcHpZMmhsYldGekxXMXBZM0p2YzI5bWRDMWpiMjA2YjJabWFXTmxPbVY0WTJWc1hDSWdlRzFzYm5NNmJUMWNJbWgwZEhBNkx5OXpZMmhsYldGekxtMXBZM0p2YzI5bWRDNWpiMjB2YjJabWFXTmxMekl3TURRdk1USXZiMjF0YkZ3aUlIaHRiRzV6UFZ3aWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdlZGSXZVa1ZETFdoMGJXdzBNRndpUGx4eVhHNDhhR1ZoWkQ1Y2NseHVQRzFsZEdFZ2FIUjBjQzFsY1hWcGRqMWNJa052Ym5SbGJuUXRWSGx3WlZ3aUlHTnZiblJsYm5ROVhDSjBaWGgwTDJoMGJXdzdJR05vWVhKelpYUTlhMjlwT0MxeVhDSStYSEpjYmp4dFpYUmhJRzVoYldVOVhDSkhaVzVsY21GMGIzSmNJaUJqYjI1MFpXNTBQVndpVFdsamNtOXpiMlowSUZkdmNtUWdNVFVnS0dacGJIUmxjbVZrSUcxbFpHbDFiU2xjSWo1Y2NseHVQQ0V0TFZ0cFppQWhiWE52WFQ0OGMzUjViR1UrZGx4Y09pb2dlMkpsYUdGMmFXOXlPblZ5YkNnalpHVm1ZWFZzZENOV1RVd3BPMzFjY2x4dWIxeGNPaW9nZTJKbGFHRjJhVzl5T25WeWJDZ2paR1ZtWVhWc2RDTldUVXdwTzMxY2NseHVkMXhjT2lvZ2UySmxhR0YyYVc5eU9uVnliQ2dqWkdWbVlYVnNkQ05XVFV3cE8zMWNjbHh1TG5Ob1lYQmxJSHRpWldoaGRtbHZjanAxY213b0kyUmxabUYxYkhRalZrMU1LVHQ5WEhKY2JqeGNMM04wZVd4bFBqd2hXMlZ1WkdsbVhTMHRQanh6ZEhsc1pUNDhJUzB0WEhKY2JpOHFJRVp2Ym5RZ1JHVm1hVzVwZEdsdmJuTWdLaTljY2x4dVFHWnZiblF0Wm1GalpWeHlYRzVjZEh0bWIyNTBMV1poYldsc2VUcGNJa05oYldKeWFXRWdUV0YwYUZ3aU8xeHlYRzVjZEhCaGJtOXpaUzB4T2pJZ05DQTFJRE1nTlNBMElEWWdNeUF5SURRN2ZWeHlYRzVBWm05dWRDMW1ZV05sWEhKY2JseDBlMlp2Ym5RdFptRnRhV3g1T2tOaGJHbGljbWs3WEhKY2JseDBjR0Z1YjNObExURTZNaUF4TlNBMUlESWdNaUF5SURRZ015QXlJRFE3ZlZ4eVhHNUFabTl1ZEMxbVlXTmxYSEpjYmx4MGUyWnZiblF0Wm1GdGFXeDVPbFJoYUc5dFlUdGNjbHh1WEhSd1lXNXZjMlV0TVRveUlERXhJRFlnTkNBeklEVWdOQ0EwSURJZ05EdDlYSEpjYmk4cUlGTjBlV3hsSUVSbFptbHVhWFJwYjI1eklDb3ZYSEpjYm5BdVRYTnZUbTl5YldGc0xDQnNhUzVOYzI5T2IzSnRZV3dzSUdScGRpNU5jMjlPYjNKdFlXeGNjbHh1WEhSN2JXRnlaMmx1T2pCamJUdGNjbHh1WEhSdFlYSm5hVzR0WW05MGRHOXRPaTR3TURBeGNIUTdYSEpjYmx4MFptOXVkQzF6YVhwbE9qRXhMakJ3ZER0Y2NseHVYSFJtYjI1MExXWmhiV2xzZVRwY0lrTmhiR2xpY21sY0lpeHpZVzV6TFhObGNtbG1PMXh5WEc1Y2RHMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPa1ZPTFZWVE8zMWNjbHh1WVRwc2FXNXJMQ0J6Y0dGdUxrMXpiMGg1Y0dWeWJHbHVhMXh5WEc1Y2RIdHRjMjh0YzNSNWJHVXRjSEpwYjNKcGRIazZPVGs3WEhKY2JseDBZMjlzYjNJNkl6QTFOak5ETVR0Y2NseHVYSFIwWlhoMExXUmxZMjl5WVhScGIyNDZkVzVrWlhKc2FXNWxPMzFjY2x4dVlUcDJhWE5wZEdWa0xDQnpjR0Z1TGsxemIwaDVjR1Z5YkdsdWEwWnZiR3h2ZDJWa1hISmNibHgwZTIxemJ5MXpkSGxzWlMxd2NtbHZjbWwwZVRvNU9UdGNjbHh1WEhSamIyeHZjam9qT1RVMFJqY3lPMXh5WEc1Y2RIUmxlSFF0WkdWamIzSmhkR2x2YmpwMWJtUmxjbXhwYm1VN2ZWeHlYRzV3TG0xemIyNXZjbTFoYkRBc0lHeHBMbTF6YjI1dmNtMWhiREFzSUdScGRpNXRjMjl1YjNKdFlXd3dYSEpjYmx4MGUyMXpieTF6ZEhsc1pTMXVZVzFsT20xemIyNXZjbTFoYkR0Y2NseHVYSFJ0YzI4dGMzUjViR1V0Y0hKcGIzSnBkSGs2T1RrN1hISmNibHgwYlhOdkxXMWhjbWRwYmkxMGIzQXRZV3gwT21GMWRHODdYSEpjYmx4MGJXRnlaMmx1TFhKcFoyaDBPakJqYlR0Y2NseHVYSFJ0YzI4dGJXRnlaMmx1TFdKdmRIUnZiUzFoYkhRNllYVjBienRjY2x4dVhIUnRZWEpuYVc0dGJHVm1kRG93WTIwN1hISmNibHgwWm05dWRDMXphWHBsT2pFeUxqQndkRHRjY2x4dVhIUm1iMjUwTFdaaGJXbHNlVHBjSWxScGJXVnpJRTVsZHlCU2IyMWhibHdpTEhObGNtbG1PMzFjY2x4dWMzQmhiaTVGYldGcGJGTjBlV3hsTVRsY2NseHVYSFI3YlhOdkxYTjBlV3hsTFhSNWNHVTZjR1Z5YzI5dVlXdzdYSEpjYmx4MFptOXVkQzFtWVcxcGJIazZYQ0pEWVd4cFluSnBYQ0lzYzJGdWN5MXpaWEpwWmp0Y2NseHVYSFJqYjJ4dmNqcDNhVzVrYjNkMFpYaDBPMzFjY2x4dWMzQmhiaTVGYldGcGJGTjBlV3hsTWpCY2NseHVYSFI3YlhOdkxYTjBlV3hsTFhSNWNHVTZjR1Z5YzI5dVlXdzdYSEpjYmx4MFptOXVkQzFtWVcxcGJIazZYQ0pEWVd4cFluSnBYQ0lzYzJGdWN5MXpaWEpwWmp0Y2NseHVYSFJqYjJ4dmNqb2pNVVkwT1RkRU8zMWNjbHh1YzNCaGJpNUZiV0ZwYkZOMGVXeGxNakpjY2x4dVhIUjdiWE52TFhOMGVXeGxMWFI1Y0dVNmNHVnljMjl1WVd3dGNtVndiSGs3WEhKY2JseDBabTl1ZEMxbVlXMXBiSGs2WENKRFlXeHBZbkpwWENJc2MyRnVjeTF6WlhKcFpqdGNjbHh1WEhSamIyeHZjanAzYVc1a2IzZDBaWGgwTzMxY2NseHVMazF6YjBOb2NFUmxabUYxYkhSY2NseHVYSFI3YlhOdkxYTjBlV3hsTFhSNWNHVTZaWGh3YjNKMExXOXViSGs3WEhKY2JseDBabTl1ZEMxemFYcGxPakV3TGpCd2REdDlYSEpjYmtCd1lXZGxJRmR2Y21SVFpXTjBhVzl1TVZ4eVhHNWNkSHR6YVhwbE9qWXhNaTR3Y0hRZ056a3lMakJ3ZER0Y2NseHVYSFJ0WVhKbmFXNDZNaTR3WTIwZ05ESXVOWEIwSURJdU1HTnRJRE11TUdOdE8zMWNjbHh1WkdsMkxsZHZjbVJUWldOMGFXOXVNVnh5WEc1Y2RIdHdZV2RsT2xkdmNtUlRaV04wYVc5dU1UdDlYSEpjYmkwdFBqeGNMM04wZVd4bFBqd2hMUzFiYVdZZ1ozUmxJRzF6YnlBNVhUNDhlRzFzUGx4eVhHNDhienB6YUdGd1pXUmxabUYxYkhSeklIWTZaWGgwUFZ3aVpXUnBkRndpSUhOd2FXUnRZWGc5WENJeE1ESTJYQ0lnTHo1Y2NseHVQRnd2ZUcxc1Bqd2hXMlZ1WkdsbVhTMHRQandoTFMxYmFXWWdaM1JsSUcxemJ5QTVYVDQ4ZUcxc1BseHlYRzQ4YnpwemFHRndaV3hoZVc5MWRDQjJPbVY0ZEQxY0ltVmthWFJjSWo1Y2NseHVQRzg2YVdSdFlYQWdkanBsZUhROVhDSmxaR2wwWENJZ1pHRjBZVDFjSWpGY0lpQXZQbHh5WEc0OFhDOXZPbk5vWVhCbGJHRjViM1YwUGp4Y0wzaHRiRDQ4SVZ0bGJtUnBabDB0TFQ1Y2NseHVQRnd2YUdWaFpENWNjbHh1UEdKdlpIa2diR0Z1WnoxY0lsSlZYQ0lnYkdsdWF6MWNJaU13TlRZelF6RmNJaUIyYkdsdWF6MWNJaU01TlRSR056SmNJajVjY2x4dVBHUnBkaUJqYkdGemN6MWNJbGR2Y21SVFpXTjBhVzl1TVZ3aVBseHlYRzQ4Y0NCamJHRnpjejFjSWsxemIwNXZjbTFoYkZ3aVB0Q1YwTHZRdGRDOTBMQXNJTkMvMFlEUXZ0R0IwWXpRc2RDd0lOQzZJTkMwMExEUXZkQzkwWXZRdkNEUXY5QyswTGZRdU5HRzBMalJqOUM4SU5DMDBMN1FzZEN3MExMUXVOR0MwWXdnMFlEUXRkQzMwTHJSZ3pvZ1BHODZjRDQ4WEM5dk9uQStQRnd2Y0Q1Y2NseHVQSEFnWTJ4aGMzTTlYQ0pOYzI5T2IzSnRZV3hjSWo0dDBKL1JnTkMrMFlUUXVOQzcwWXpRdmRDdzBZOGcwWUxSZ05HRDBMSFFzQ0E0TUNvNE1Db3pJQ1lqT0RJeE1Uc2dOQ0RRdk5DMTBZTFJnTkN3TGp4dk9uQStQRnd2Ynpwd1BqeGNMM0ErWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krTGRDbzBMTFF0ZEM3MEx2UXRkR0FJTkN6TDlDNkxDQXhNTkNmSUNZak9ESXhNVHNnTWpBZzBMd3VJRHh2T25BK1BGd3ZienB3UGp4Y0wzQStYSEpjYmp4d0lHTnNZWE56UFZ3aVRYTnZUbTl5YldGc1hDSStMZENpMFlEUmc5Q3gwTEFnMEpMUWs5Q2ZJREl3S2pJc09DQW1Jemd5TVRFN0lERWcwTHd1SUR4dk9uQStQRnd2Ynpwd1BqeGNMM0ErWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krUEc4NmNENG1ibUp6Y0RzOFhDOXZPbkErUEZ3dmNENWNjbHh1UEhBZ1kyeGhjM005WENKTmMyOU9iM0p0WVd4Y0lqNDhienB3UGladVluTndPenhjTDI4NmNENDhYQzl3UGx4eVhHNDhaR2wyUGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4emNHRnVJSE4wZVd4bFBWd2liWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqN1FvU0RSZzlDeTBMRFF0dEMxMEwzUXVOQzEwTHdzSUR4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4YzNCaGJpQnpkSGxzWlQxY0ltMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWWENJKzBLSFF0ZEdBMExQUXRkQzVJTkNXMFlQUXV0QyswTEk4Ynpwd1BqeGNMMjg2Y0Q0OFhDOXpjR0Z1UGp4Y0wzQStYSEpjYmp4d0lHTnNZWE56UFZ3aVRYTnZUbTl5YldGc1hDSStQSE53WVc0Z2MzUjViR1U5WENKdGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWVndpUHRDYzBMWFF2ZEMxMExUUXR0QzEwWUFnMEwvUXZpRFF0OUN3MExyUmc5Qy8wTHJRc05DOFBHODZjRDQ4WEM5dk9uQStQRnd2YzNCaGJqNDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4emNHRnVJSE4wZVd4bFBWd2liWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqN1FvdEMxMExzdU9pQW1JelF6T3pjb016UXpLU0F6TnprdE5ESXROellnS05DeTBMM1JnOUdDMFlEUXRkQzkwTDNRdU5DNUlOQzkwTDdRdk5DMTBZQXBMQ0RRbk5DKzBMRXVPaUFtSXpRek96Y3RPVFkyTFRjd015MDROUzB5Tmp4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBGd3ZaR2wyUGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4dk9uQStKbTVpYzNBN1BGd3ZienB3UGp4Y0wzQStYSEpjYmp4a2FYWStYSEpjYmp4a2FYWWdjM1I1YkdVOVhDSmliM0prWlhJNmJtOXVaVHRpYjNKa1pYSXRkRzl3T25OdmJHbGtJQ05GTVVVeFJURWdNUzR3Y0hRN2NHRmtaR2x1WnpvekxqQndkQ0F3WTIwZ01HTnRJREJqYlZ3aVBseHlYRzQ4Y0NCamJHRnpjejFjSWsxemIwNXZjbTFoYkZ3aVBqeGlQanh6Y0dGdUlITjBlV3hsUFZ3aWJYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFZjSWo1R2NtOXRPanhjTDNOd1lXNCtQRnd2WWo0OGMzQmhiaUJ6ZEhsc1pUMWNJbTF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVlhDSStJTkNSMExYUXU5QyswTEhSZ05DKzBMTFFzQ0RRbGRDNzBMWFF2ZEN3SU5DUzBMRFF1OUMxMFlEUmpOQzEwTExRdmRDd0lDWnNkRHRpWld4dlluSnZkbUZBYzNCckxuSjFKbWQwTzF4eVhHNDhZbkkrWEhKY2JqeGlQbE5sYm5RNlBGd3ZZajRnVjJWa2JtVnpaR0Y1TENCS1lXNTFZWEo1SURJNUxDQXlNREkxSURRNk16UWdVRTA4WW5JK1hISmNianhpUGxSdk9qeGNMMkkrSU5DVzBZUFF1dEMrMExJZzBLSFF0ZEdBMExQUXRkQzVJTkNRMEx2UXRkQzYwWUhRc05DOTBMVFJnTkMrMExMUXVOR0hJQ1pzZER0emVtaDFhMjkyUUhWemMyTXVjblVtWjNRN1BHSnlQbHh5WEc0OFlqNVRkV0pxWldOME9qeGNMMkkrSUZKRk9pQkVVeTB5TXpFeE16UThienB3UGp4Y0wyODZjRDQ4WEM5emNHRnVQanhjTDNBK1hISmNianhjTDJScGRqNWNjbHh1UEZ3dlpHbDJQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanh2T25BK0ptNWljM0E3UEZ3dmJ6cHdQanhjTDNBK1hISmNianh3SUdOc1lYTnpQVndpVFhOdlRtOXliV0ZzWENJZ2MzUjViR1U5WENKc2FXNWxMV2hsYVdkb2REb3hNaTR3Y0hRN1ltRmphMmR5YjNWdVpEb2pSa1pGUWpsRFhDSStQR0krUEhOd1lXNGdjM1I1YkdVOVhDSm1iMjUwTFhOcGVtVTZNVEF1TUhCME8yTnZiRzl5T21Kc1lXTnJYQ0krMEpMUW5kQ1kwSnpRa05DZDBKalFsU0U4WEM5emNHRnVQanhjTDJJK1BITndZVzRnYzNSNWJHVTlYQ0ptYjI1MExYTnBlbVU2TVRBdU1IQjBPMk52Ykc5eU9tSnNZV05yWENJK0lOQ2YwTGpSZ2RHTTBMelF2aURRc2RHTDBMdlF2aURRdnRHQzBML1JnTkN3MExMUXU5QzEwTDNRdmlEUXN0QzkwTFhSaU5DOTBMalF2Q0RRdnRHQzBML1JnTkN3MExMUXVOR0MwTFhRdTlDMTBMd3VJTkNkMExVZzBML1F0ZEdBMExYUmhkQyswTFRRdU5HQzBMVWcwTC9RdmlEUmdkR0IwWXZRdTlDNjBMRFF2Q0RRdUNEUXZkQzFJTkMrMFlMUXV0R0EwWXZRc3RDdzBMblJndEMxWEhKY2JpRFFzdEM3MEw3UXR0QzEwTDNRdU5HUExDRFF2OUMrMExyUXNDRFF2ZEMxSU5HRDBMSFF0ZEMwMExqUmd0QzEwWUhSakN3ZzBZZlJndEMrSU5HTjBZTFF2aURRc2RDMTBMZlF2dEMvMExEUmdkQzkwTDR1SUR4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4YzNCaGJpQnpkSGxzWlQxY0ltWnZiblF0YzJsNlpUb3hNaTR3Y0hRN1ptOXVkQzFtWVcxcGJIazZKbkYxYjNRN1ZHbHRaWE1nVG1WM0lGSnZiV0Z1Sm5GMWIzUTdMSE5sY21sbU8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWWENJK1BHODZjRDRtYm1KemNEczhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OFpHbDJQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanh6Y0dGdUlITjBlV3hsUFZ3aVkyOXNiM0k2SXpGR05EazNSRndpUHRDVTBMN1FzZEdBMFl2UXVTRFF0TkMxMEwzUmpDd2cwS0hRdGRHQTBMUFF0ZEM1SVR4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4YzNCaGJpQnpkSGxzWlQxY0ltTnZiRzl5T2lNeFJqUTVOMFJjSWo0OGJ6cHdQaVp1WW5Od096eGNMMjg2Y0Q0OFhDOXpjR0Z1UGp4Y0wzQStYSEpjYmp4d0lHTnNZWE56UFZ3aVRYTnZUbTl5YldGc1hDSStQSE53WVc0Z2MzUjViR1U5WENKamIyeHZjam9qTVVZME9UZEVYQ0krMEovUmdOQyswWWpSZ3lEUXY5R0EwTDdRc3RDMTBZRFF1TkdDMFl3OGJ6cHdQanhjTDI4NmNENDhYQzl6Y0dGdVBqeGNMM0ErWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krUEhOd1lXNGdjM1I1YkdVOVhDSmpiMnh2Y2pvak1VWTBPVGRFWENJK1BHODZjRDRtYm1KemNEczhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OFpHbDJQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanh6Y0dGdUlITjBlV3hsUFZ3aVkyOXNiM0k2SXpGR05EazNSRHR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQanh2T25BK0ptNWljM0E3UEZ3dmJ6cHdQanhjTDNOd1lXNCtQRnd2Y0Q1Y2NseHVQSEFnWTJ4aGMzTTlYQ0pOYzI5T2IzSnRZV3hjSWo0OGMzQmhiaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMVJoYUc5dFlTWnhkVzkwT3l4ellXNXpMWE5sY21sbU8yTnZiRzl5T2lNeFJqUkZOems3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVmNJajdRb1NEUmc5Q3kwTERRdHRDMTBMM1F1TkMxMEx3c1BGd3ZjM0JoYmo0OGMzQmhiaUJ6ZEhsc1pUMWNJbVp2Ym5RdGMybDZaVG94TWk0d2NIUTdabTl1ZEMxbVlXMXBiSGs2Sm5GMWIzUTdWR0ZvYjIxaEpuRjFiM1E3TEhOaGJuTXRjMlZ5YVdZN1kyOXNiM0k2SXpGR05FVTNPVHR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQanh2T25BK1BGd3ZienB3UGp4Y0wzTndZVzQrUEZ3dmNENWNjbHh1UEhBZ1kyeGhjM005WENKTmMyOU9iM0p0WVd4Y0lqNDhjM0JoYmlCemRIbHNaVDFjSW1admJuUXRabUZ0YVd4NU9pWnhkVzkwTzFSaGFHOXRZU1p4ZFc5ME95eHpZVzV6TFhObGNtbG1PMk52Ykc5eU9pTXhSalJGTnprN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFZjSWo1Q1pYTjBJSEpsWjJGeVpITXNYSEpjYmp4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4WWo0OGMzQmhiaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMVJoYUc5dFlTWnhkVzkwT3l4ellXNXpMWE5sY21sbU8yTnZiRzl5T2lNeFJqUkZOems3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVmNJajdRa2RDMTBMdlF2dEN4MFlEUXZ0Q3kwTEFnMEpYUXU5QzEwTDNRc0NEUWt0Q3cwTHZRdGRHQTBZelF0ZEN5MEwzUXNEeHZPbkErUEZ3dmJ6cHdQanhjTDNOd1lXNCtQRnd2WWo0OFhDOXdQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanhpUGp4emNHRnVJR3hoYm1jOVhDSkZUaTFWVTF3aUlITjBlV3hsUFZ3aVptOXVkQzFtWVcxcGJIazZKbkYxYjNRN1ZHRm9iMjFoSm5GMWIzUTdMSE5oYm5NdGMyVnlhV1k3WTI5c2IzSTZJekZHTkVVM09UdHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVBrSmxiRzlpY205MllTQkZiR1Z1WVR4Y0wzTndZVzQrUEZ3dllqNDhZajQ4YzNCaGJpQnpkSGxzWlQxY0ltWnZiblF0Wm1GdGFXeDVPaVp4ZFc5ME8xUmhhRzl0WVNaeGRXOTBPeXh6WVc1ekxYTmxjbWxtTzJOdmJHOXlPaU14UmpSRk56azdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqNDhienB3UGp4Y0wyODZjRDQ4WEM5emNHRnVQanhjTDJJK1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4YzNCaGJpQnpkSGxzWlQxY0ltWnZiblF0Wm1GdGFXeDVPaVp4ZFc5ME8xUmhhRzl0WVNaeGRXOTBPeXh6WVc1ekxYTmxjbWxtTzJOdmJHOXlPaU14UmpSRk56azdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqN1FuTkMxMEwzUXRkQzAwTGJRdGRHQUlOQyswWUxRdE5DMTBMdlFzQ0RRdjlHQTBMN1F0TkN3MExZbWJtSnpjRHNnMEpEUW5pQW1iR0Z4ZFc4NzBLSFJndEN3MEx2UXRkQy8wWURRdnRDODBZdlJpTkM3MExYUXZkQzkwTERSanlEUXV0QyswTHpRdjlDdzBMM1F1TkdQSm5KaGNYVnZPenh2T25BK1BGd3ZienB3UGp4Y0wzTndZVzQrUEZ3dmNENWNjbHh1UEhBZ1kyeGhjM005WENKTmMyOU9iM0p0WVd4Y0lqNDhjM0JoYmlCc1lXNW5QVndpUlU0dFZWTmNJaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMEZ5YVdGc0puRjFiM1E3TEhOaGJuTXRjMlZ5YVdZN1kyOXNiM0k2SXpKR05UUTVOanR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQazFoYm1GblpYSWdiMllnYzJGc1pYTWdSR1Z3WVhKMGJXVnVkRHhjTDNOd1lXNCtQSE53WVc0Z2JHRnVaejFjSWtWT0xWVlRYQ0lnYzNSNWJHVTlYQ0ptYjI1MExXWmhiV2xzZVRvbWNYVnZkRHRVWVdodmJXRW1jWFZ2ZERzc2MyRnVjeTF6WlhKcFpqdGpiMnh2Y2pvak1VWTBSVGM1TzIxemJ5MW1ZWEpsWVhOMExXeGhibWQxWVdkbE9sSlZYQ0krSUNac1lYRjFienRUZEdWbGJDMUpibVIxYzNSeWFXRnNYSEpjYmlCRGIyMXdZVzU1Sm5KaGNYVnZPenh2T25BK1BGd3ZienB3UGp4Y0wzTndZVzQrUEZ3dmNENWNjbHh1UEhBZ1kyeGhjM005WENKTmMyOU9iM0p0WVd4Y0lqNDhjM0JoYmlCc1lXNW5QVndpUlU0dFZWTmNJaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMVJoYUc5dFlTWnhkVzkwT3l4ellXNXpMWE5sY21sbU8yTnZiRzl5T2lNeFJqUkZOems3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVmNJajVGTFcxaGFXdzZYSEpjYmp4aElHaHlaV1k5WENKdFlXbHNkRzg2WW1Wc2IySnliM1poUUhOd2F5NXlkVndpUG1KbGJHOWljbTkyWVVCemNHc3VjblU4WEM5aFBqeGNMM053WVc0K1BITndZVzRnYkdGdVp6MWNJa1ZPTFZWVFhDSWdjM1I1YkdVOVhDSm1iMjUwTFdaaGJXbHNlVG9tY1hWdmREdFVhVzFsY3lCT1pYY2dVbTl0WVc0bWNYVnZkRHNzYzJWeWFXWTdZMjlzYjNJNkl6RkdORGszUkR0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWVndpUGp4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4YzNCaGJpQnpkSGxzWlQxY0ltWnZiblF0Wm1GdGFXeDVPaVp4ZFc5ME8xUmhhRzl0WVNaeGRXOTBPeXh6WVc1ekxYTmxjbWxtTzJOdmJHOXlPaU14UmpSRk56azdiWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqN1FvdEMxMExzOFhDOXpjR0Z1UGp4emNHRnVJR3hoYm1jOVhDSkZUaTFWVTF3aUlITjBlV3hsUFZ3aVptOXVkQzFtWVcxcGJIazZKbkYxYjNRN1ZHRm9iMjFoSm5GMWIzUTdMSE5oYm5NdGMyVnlhV1k3WTI5c2IzSTZJekZHTkVVM09UdHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVBpNHZQRnd2YzNCaGJqNDhjM0JoYmlCemRIbHNaVDFjSW1admJuUXRabUZ0YVd4NU9pWnhkVzkwTzFSaGFHOXRZU1p4ZFc5ME95eHpZVzV6TFhObGNtbG1PMk52Ykc5eU9pTXhSalJGTnprN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFZjSWo3UXBOQ3cwTHJSZ1R4Y0wzTndZVzQrUEhOd1lXNGdiR0Z1WnoxY0lrVk9MVlZUWENJZ2MzUjViR1U5WENKbWIyNTBMV1poYldsc2VUb21jWFZ2ZER0VVlXaHZiV0VtY1hWdmREc3NjMkZ1Y3kxelpYSnBaanRqYjJ4dmNqb2pNVVkwUlRjNU8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWWENJK09seHlYRzRnSmlNME16czNJQ2d6TkRNcElETTFPUzB6T1Mwek9TQW9QRnd2YzNCaGJqNDhjM0JoYmlCemRIbHNaVDFjSW1admJuUXRabUZ0YVd4NU9pWnhkVzkwTzFSaGFHOXRZU1p4ZFc5ME95eHpZVzV6TFhObGNtbG1PMk52Ykc5eU9pTXhSalJGTnprN2JYTnZMV1poY21WaGMzUXRiR0Z1WjNWaFoyVTZVbFZjSWo3UXROQyswTEU4WEM5emNHRnVQanh6Y0dGdUlHeGhibWM5WENKRlRpMVZVMXdpSUhOMGVXeGxQVndpWm05dWRDMW1ZVzFwYkhrNkpuRjFiM1E3VkdGb2IyMWhKbkYxYjNRN0xITmhibk10YzJWeWFXWTdZMjlzYjNJNkl6RkdORVUzT1R0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWVndpUGk0Z05EVXRNek1wUEc4NmNENDhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanhpUGp4emNHRnVJSE4wZVd4bFBWd2labTl1ZEMxbVlXMXBiSGs2Sm5GMWIzUTdWR0ZvYjIxaEpuRjFiM1E3TEhOaGJuTXRjMlZ5YVdZN1kyOXNiM0k2SXpGR05FVTNPVHR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQdENjMEw3UXNTN1JndEMxMExzdU9pQW1JelF6T3pjdFBGd3ZjM0JoYmo0OFhDOWlQanhpUGp4emNHRnVJR3hoYm1jOVhDSkZUaTFWVTF3aUlITjBlV3hsUFZ3aVptOXVkQzFtWVcxcGJIazZKbkYxYjNRN1ZHRm9iMjFoSm5GMWIzUTdMSE5oYm5NdGMyVnlhV1k3WTI5c2IzSTZJekZHTkVVM09UdHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVBqazJNeTAwTkRVdE1qQTJOenh2T25BK1BGd3ZienB3UGp4Y0wzTndZVzQrUEZ3dllqNDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4emNHRnVJSE4wZVd4bFBWd2labTl1ZEMxemFYcGxPakV3TGpCd2REdG1iMjUwTFdaaGJXbHNlVG9tY1hWdmREdFVZV2h2YldFbWNYVnZkRHNzYzJGdWN5MXpaWEpwWmp0amIyeHZjam9qTURBMU5qazJPMjF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVlhDSStQRzg2Y0Q0bWJtSnpjRHM4WEM5dk9uQStQRnd2YzNCaGJqNDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4emNHRnVJSE4wZVd4bFBWd2lZMjlzYjNJNkl6RkdORGszUkR0dGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWVndpUGp4cGJXY2dZbTl5WkdWeVBWd2lNRndpSUhkcFpIUm9QVndpTlRNelhDSWdhR1ZwWjJoMFBWd2lNVEkxWENJZ2MzUjViR1U5WENKM2FXUjBhRG8xTGpVMU1tbHVPMmhsYVdkb2REb3hMak13TW1sdVhDSWdhV1E5WENMUW9OQzQwWUhSZzlDOTBMN1F1bDk0TURBeU1GODBYQ0lnYzNKalBWd2lZMmxrT21sdFlXZGxNREF4TG5CdVowQXdNVVJDTnpJMlF5NDFOREEwT0VJMk1Gd2lJR0ZzZEQxY0ltTnBaRHBwYldGblpUQXdNaTV3Ym1kQU1ERkVRVUZFUmpJdU5VUkdORFkyUXpCY0lqNDhienB3UGp4Y0wyODZjRDQ4WEM5emNHRnVQanhjTDNBK1hISmNianh3SUdOc1lYTnpQVndpVFhOdlRtOXliV0ZzWENJK1BITndZVzRnYzNSNWJHVTlYQ0pqYjJ4dmNqb2pNVVkwT1RkRU8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWWENJK1BHODZjRDRtYm1KemNEczhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanh6Y0dGdUlITjBlV3hsUFZ3aVkyOXNiM0k2SXpGR05EazNSRHR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQanhwYldjZ1ltOXlaR1Z5UFZ3aU1Gd2lJSGRwWkhSb1BWd2lNalk1WENJZ2FHVnBaMmgwUFZ3aU5qQmNJaUJ6ZEhsc1pUMWNJbmRwWkhSb09qSXVPREF5YVc0N2FHVnBaMmgwT2k0Mk1qVnBibHdpSUdsa1BWd2kwS0RRdU5HQjBZUFF2ZEMrMExwZmVEQXdNakJmTTF3aUlITnlZejFjSW1OcFpEcHBiV0ZuWlRBd01pNXFjR2RBTURGRVFqY3lOa011TlRRd05EaENOakJjSWlCaGJIUTlYQ0pqYVdRNmFXMWhaMlV3TURNdWFuQm5RREF4UkRBMlFrRkdMa00wTTBORE5EY3dYQ0krUEc4NmNENDhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanh6Y0dGdUlITjBlV3hsUFZ3aVkyOXNiM0k2SXpGR05EazNSRHR0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQanhoSUdoeVpXWTlYQ0pvZEhSd09pOHZkM2QzTG5Od2F5NXlkUzljSWo0OFlqNDhjM0JoYmlCc1lXNW5QVndpUlU0dFZWTmNJaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMVJoYUc5dFlTWnhkVzkwT3l4ellXNXpMWE5sY21sbU8yTnZiRzl5T21Kc2RXVmNJajUzZDNjOFhDOXpjR0Z1UGp4Y0wySStQR0krUEhOd1lXNGdjM1I1YkdVOVhDSm1iMjUwTFdaaGJXbHNlVG9tY1hWdmREdFVZV2h2YldFbWNYVnZkRHNzYzJGdWN5MXpaWEpwWmp0amIyeHZjanBpYkhWbFhDSStManhjTDNOd1lXNCtQRnd2WWo0OFlqNDhjM0JoYmlCc1lXNW5QVndpUlU0dFZWTmNJaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMVJoYUc5dFlTWnhkVzkwT3l4ellXNXpMWE5sY21sbU8yTnZiRzl5T21Kc2RXVmNJajV6Y0dzOFhDOXpjR0Z1UGp4Y0wySStQR0krUEhOd1lXNGdjM1I1YkdVOVhDSm1iMjUwTFdaaGJXbHNlVG9tY1hWdmREdFVZV2h2YldFbWNYVnZkRHNzYzJGdWN5MXpaWEpwWmp0amIyeHZjanBpYkhWbFhDSStManhjTDNOd1lXNCtQRnd2WWo0OFlqNDhjM0JoYmlCc1lXNW5QVndpUlU0dFZWTmNJaUJ6ZEhsc1pUMWNJbVp2Ym5RdFptRnRhV3g1T2laeGRXOTBPMVJoYUc5dFlTWnhkVzkwT3l4ellXNXpMWE5sY21sbU8yTnZiRzl5T21Kc2RXVmNJajV5ZFR4Y0wzTndZVzQrUEZ3dllqNDhYQzloUGp4dk9uQStQRnd2Ynpwd1BqeGNMM053WVc0K1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajQ4YzNCaGJpQnpkSGxzWlQxY0ltTnZiRzl5T2lNeFJqUTVOMFE3YlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVmNJajQ4Ynpwd1BpWnVZbk53T3p4Y0wyODZjRDQ4WEM5emNHRnVQanhjTDNBK1hISmNianh3SUdOc1lYTnpQVndpVFhOdlRtOXliV0ZzWENJK1BITndZVzRnYzNSNWJHVTlYQ0pqYjJ4dmNqb2pNVVkwT1RkRU8yMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWWENJK1BHODZjRDRtYm1KemNEczhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OFhDOWthWFkrWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krUEhOd1lXNGdjM1I1YkdVOVhDSmpiMnh2Y2pvak1VWTBPVGRFWENJK1BHODZjRDRtYm1KemNEczhYQzl2T25BK1BGd3ZjM0JoYmo0OFhDOXdQbHh5WEc0OFpHbDJQbHh5WEc0OFpHbDJJSE4wZVd4bFBWd2lZbTl5WkdWeU9tNXZibVU3WW05eVpHVnlMWFJ2Y0RwemIyeHBaQ0FqUlRGRk1VVXhJREV1TUhCME8zQmhaR1JwYm1jNk15NHdjSFFnTUdOdElEQmpiU0F3WTIxY0lqNWNjbHh1UEhBZ1kyeGhjM005WENKTmMyOU9iM0p0WVd4Y0lqNDhZajQ4YzNCaGJpQnpkSGxzWlQxY0ltMXpieTFtWVhKbFlYTjBMV3hoYm1kMVlXZGxPbEpWWENJK1JuSnZiVG84WEM5emNHRnVQanhjTDJJK1BITndZVzRnYzNSNWJHVTlYQ0p0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQaURRbHRHRDBMclF2dEN5SU5DaDBMWFJnTkN6MExYUXVTRFFrTkM3MExYUXV0R0IwTERRdmRDMDBZRFF2dEN5MExqUmh5QW1iSFE3UEdFZ2FISmxaajFjSW0xaGFXeDBienB6ZW1oMWEyOTJRSFZ6YzJNdWNuVmNJajV6ZW1oMWEyOTJRSFZ6YzJNdWNuVThYQzloUGlabmREdGNjbHh1UEdKeVBseHlYRzQ4WWo1VFpXNTBPanhjTDJJK0lGZGxaRzVsYzJSaGVTd2dTbUZ1ZFdGeWVTQXlPU3dnTWpBeU5TQXpPakUwSUZCTlBHSnlQbHh5WEc0OFlqNVViem84WEM5aVBpRFFrZEMxMEx2UXZ0Q3gwWURRdnRDeTBMQWcwSlhRdTlDMTBMM1FzQ0RRa3RDdzBMdlF0ZEdBMFl6UXRkQ3kwTDNRc0NBbWJIUTdQR0VnYUhKbFpqMWNJbTFoYVd4MGJ6cGlaV3h2WW5KdmRtRkFjM0JyTG5KMVhDSStZbVZzYjJKeWIzWmhRSE53YXk1eWRUeGNMMkUrSm1kME96eGljajVjY2x4dVBHSStVM1ZpYW1WamREbzhYQzlpUGlCRVV5MHlNekV4TXpROGJ6cHdQanhjTDI4NmNENDhYQzl6Y0dGdVBqeGNMM0ErWEhKY2JqeGNMMlJwZGo1Y2NseHVQRnd2WkdsMlBseHlYRzQ4Y0NCamJHRnpjejFjSWsxemIwNXZjbTFoYkZ3aVBqeHZPbkErSm01aWMzQTdQRnd2Ynpwd1BqeGNMM0ErWEhKY2JqeHdQanhwUGp4emNHRnVJSE4wZVd4bFBWd2labTl1ZEMxemFYcGxPakV3TGpCd2REdGpiMnh2Y2pwaWJIVmxYQ0krMEpMUW5kQ1YwS2pRbmRDdjBLOGcwSi9RbnRDbjBLTFFrRG9nMEpYUmdkQzcwTGdnMEw3Umd0Qy8wWURRc05DeTBMalJndEMxMEx2UmpDRFF2ZEMxMExqUXQ5Q3kwTFhSZ2RHQzBMWFF2U3dnMEwzUXRTRFF2OUMxMFlEUXRkR0YwTDdRdE5DNDBZTFF0U0RRdjlDK0lOR0IwWUhSaTlDNzBMclFzTkM4TENEUXZkQzFJTkMrMFlMUXY5R0EwTERRc3RDNzBZL1F1ZEdDMExVZzBML1FzTkdBMEw3UXU5QzRMQ0RSZ1NEUXZ0R0IwWUxRdnRHQTBMN1F0dEM5MEw3UmdkR0MwWXpSamlEUXZ0R0MwTHJSZ05HTDBMTFFzTkM1MFlMUXRTRFFzdEM3MEw3UXR0QzEwTDNRdU5HUExqeGNMM053WVc0K1BGd3ZhVDQ4YzNCaGJpQnpkSGxzWlQxY0ltWnZiblF0YzJsNlpUb3hNQzR3Y0hRN1kyOXNiM0k2WW14MVpWd2lQanh2T25BK1BGd3ZienB3UGp4Y0wzTndZVzQrUEZ3dmNENWNjbHh1UEhBZ1kyeGhjM005WENKTmMyOU9iM0p0WVd4Y0lpQnpkSGxzWlQxY0ltMWhjbWRwYmkxaWIzUjBiMjA2TVRJdU1IQjBYQ0krUEhOd1lXNGdjM1I1YkdVOVhDSm1iMjUwTFhOcGVtVTZNVEl1TUhCME8yWnZiblF0Wm1GdGFXeDVPaVp4ZFc5ME8xUnBiV1Z6SUU1bGR5QlNiMjFoYmlaeGRXOTBPeXh6WlhKcFpqdHRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVBqeGljajVjY2x4dVBHSnlQbHh5WEc0OGJ6cHdQanhjTDI4NmNENDhYQzl6Y0dGdVBqeGNMM0ErWEhKY2JqeGthWFkrWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krMEpUUXZ0Q3gwWURSaTlDNUlOQzAwTFhRdmRHTUxDRFFsZEM3MExYUXZkQ3dManh2T25BK1BGd3ZienB3UGp4Y0wzQStYSEpjYmp4d0lHTnNZWE56UFZ3aVRYTnZUbTl5YldGc1hDSSswSi9RdnRDMDBZSFF1dEN3MExiUXVOR0MwTFVnMEwvUXZ0QzIwTERRdTlHRDBMblJnZEdDMExBZzBML1F2aURSZ2RHQzBMN1F1TkM4MEw3UmdkR0MwTGdnMEwzUXNDRFF0TkN3MEwzUXZkR0wwTFVnMEwvUXZ0QzMwTGpSaHRDNDBMZ2cwWUVnMFlQUmg5QzEwWUxRdnRDOElOR0EwTFhRdDlDNjBMZ2cwTGdnMExUUXZ0R0IwWUxRc05DeTBMclF1Q0RRdjlDK0lOQ3pMaURRbGRDNjBMRFJndEMxMFlEUXVOQzkwTEhSZzlHQTBMTTZYSEpjYmp4dk9uQStQRnd2Ynpwd1BqeGNMM0ErWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krTGRDUTBZRFF2TkN3MFlMUmc5R0EwTEFnMEpBekxDQXhNQ0RRdk5DOExpQW1Jemd5TVRFN0lEQXNNVE01SU5HQ0xpQW8wTHJSZ05DdzBZTFF2ZEMrSU5HSTBZTFJnOUM2MExVcExqeHZPbkErUEZ3dmJ6cHdQanhjTDNBK1hISmNianh3SUdOc1lYTnpQVndpVFhOdlRtOXliV0ZzWENJK0xkQ2YwWURRdnRHRTBMalF1OUdNMEwzUXNOR1BJTkdDMFlEUmc5Q3gwTEFnT0RBcU9EQXFNeUFtSXpneU1URTdJRFFnMEx6UXRkR0MwWURRc0M0Z1BHODZjRDQ4WEM5dk9uQStQRnd2Y0Q1Y2NseHVQSEFnWTJ4aGMzTTlYQ0pOYzI5T2IzSnRZV3hjSWo0dDBKdlF1TkdCMFlJZzBMTXYwTG9zSU5HQjBZSXVNeXdnTXlveE5UQXdLakl5TURBZ0ppTTRNakV4T3lBeElOR0kwWUl1UEc4NmNENDhYQzl2T25BK1BGd3ZjRDVjY2x4dVBIQWdZMnhoYzNNOVhDSk5jMjlPYjNKdFlXeGNJajR0SU5DYjBMalJnZEdDSU5Dekw5QzZMQ0RSZ2RHQ0xqTXNJRE1xTVRBd01Db3lNakF3SUNZak9ESXhNVHNnTWlEUmlOR0NManh2T25BK1BGd3ZienB3UGp4Y0wzQStYSEpjYmp4d0lHTnNZWE56UFZ3aVRYTnZUbTl5YldGc1hDSStMU0RRb3RHQTBZUFFzZEN3SU5HTkw5R0JJREUxT1NvMklDWWpPREl4TVRzZ05DdzVOeURSZ2k0Z0tOQzYwWURRc05HQzBMM1F2aURSaU5HQzBZUFF1dEMxS1M0OGJ6cHdQanhjTDI4NmNENDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGkzUXFOQ3kwTFhRdTlDNzBMWFJnQ0RRc3kvUXVpd2dNVERRbnlBbUl6Z3lNVEU3SURJd0lOQzhMaUE4Ynpwd1BqeGNMMjg2Y0Q0OFhDOXdQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQaTNRb3RHQTBZUFFzZEN3SU5DUzBKUFFueUF5TUNveUxEZ2dKaU00TWpFeE95QXhJTkM4TGlBOGJ6cHdQanhjTDI4NmNENDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4dk9uQStKbTVpYzNBN1BGd3ZienB3UGp4Y0wzQStYSEpjYmp4d0lHTnNZWE56UFZ3aVRYTnZUbTl5YldGc1hDSStQRzg2Y0Q0bWJtSnpjRHM4WEM5dk9uQStQRnd2Y0Q1Y2NseHVQSEFnWTJ4aGMzTTlYQ0pOYzI5T2IzSnRZV3hjSWo0OGJ6cHdQaVp1WW5Od096eGNMMjg2Y0Q0OFhDOXdQbHh5WEc0OGNDQmpiR0Z6Y3oxY0lrMXpiMDV2Y20xaGJGd2lQanh2T25BK0ptNWljM0E3UEZ3dmJ6cHdQanhjTDNBK1hISmNianh3SUdOc1lYTnpQVndpVFhOdlRtOXliV0ZzWENJK1BITndZVzRnYzNSNWJHVTlYQ0p0YzI4dFptRnlaV0Z6ZEMxc1lXNW5kV0ZuWlRwU1ZWd2lQdENoSU5HRDBMTFFzTkMyMExYUXZkQzQwTFhRdkN3Z1BHODZjRDQ4WEM5dk9uQStQRnd2YzNCaGJqNDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4emNHRnVJSE4wZVd4bFBWd2liWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqN1FvZEMxMFlEUXM5QzEwTGtnMEpiUmc5QzYwTDdRc2lBOGJ6cHdQanhjTDI4NmNENDhYQzl6Y0dGdVBqeGNMM0ErWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krUEhOd1lXNGdjM1I1YkdVOVhDSnRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVB0Q2MwTFhRdmRDMTBMVFF0dEMxMFlBZzBML1F2aURRdDlDdzBMclJnOUMvMExyUXNOQzhQRzg2Y0Q0OFhDOXZPbkErUEZ3dmMzQmhiajQ4WEM5d1BseHlYRzQ4Y0NCamJHRnpjejFjSWsxemIwNXZjbTFoYkZ3aVBqeHpjR0Z1SUhOMGVXeGxQVndpYlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVmNJajdRbzlHQTBMRFF1OUdNMFlIUXV0QzQwTGtnMFliUXRkQzkwWUxSZ0NEUmdkQzQwWUhSZ3RDMTBMd2cwTEhRdGRDMzBMN1F2OUN3MFlIUXZkQyswWUhSZ3RDNFBHODZjRDQ4WEM5dk9uQStQRnd2YzNCaGJqNDhYQzl3UGx4eVhHNDhjQ0JqYkdGemN6MWNJazF6YjA1dmNtMWhiRndpUGp4emNHRnVJSE4wZVd4bFBWd2liWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqNDJNakF4TURBc0lOQ1YwTHJRc05HQzBMWFJnTkM0MEwzUXNkR0QwWURRc3l3ZzBZUFF1eTdRb3RDNjBMRFJoOUMxMExrc0lOQzBMakl6TENBeE1TRFJqZEdDMExEUXRqeHZPbkErUEZ3dmJ6cHdQanhjTDNOd1lXNCtQRnd2Y0Q1Y2NseHVQSEFnWTJ4aGMzTTlYQ0pOYzI5T2IzSnRZV3hjSWo0OGMzQmhiaUJ6ZEhsc1pUMWNJbTF6YnkxbVlYSmxZWE4wTFd4aGJtZDFZV2RsT2xKVlhDSSswS0xRdGRDN0xqb2dKaU0wTXpzM0tETTBNeWtnTXpjNUxUUXlMVGMySUNqUXN0QzkwWVBSZ3RHQTBMWFF2ZEM5MExqUXVTRFF2ZEMrMEx6UXRkR0FLVnh5WEc0OGJ6cHdQanhjTDI4NmNENDhYQzl6Y0dGdVBqeGNMM0ErWEhKY2JqeHdJR05zWVhOelBWd2lUWE52VG05eWJXRnNYQ0krUEhOd1lXNGdjM1I1YkdVOVhDSnRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVB0Q2MwTDdRc1M0NklDWWpORE03TnkwNU5qWXROekF6TFRnMUxUSTJQRzg2Y0Q0OFhDOXZPbkErUEZ3dmMzQmhiajQ4WEM5d1BseHlYRzQ4Y0NCamJHRnpjejFjSWsxemIwNXZjbTFoYkZ3aVBqeHpjR0Z1SUd4aGJtYzlYQ0pGVGkxVlUxd2lJSE4wZVd4bFBWd2liWE52TFdaaGNtVmhjM1F0YkdGdVozVmhaMlU2VWxWY0lqNUZQRnd2YzNCaGJqNDhjM0JoYmlCemRIbHNaVDFjSW0xemJ5MW1ZWEpsWVhOMExXeGhibWQxWVdkbE9sSlZYQ0krTFR4Y0wzTndZVzQrUEhOd1lXNGdiR0Z1WnoxY0lrVk9MVlZUWENJZ2MzUjViR1U5WENKdGMyOHRabUZ5WldGemRDMXNZVzVuZFdGblpUcFNWVndpUG0xaGFXdzhYQzl6Y0dGdVBqeHpjR0Z1SUhOMGVXeGxQVndpYlhOdkxXWmhjbVZoYzNRdGJHRnVaM1ZoWjJVNlVsVmNJajQ2WEhKY2JqeGhJR2h5WldZOVhDSnRZV2xzZEc4NmMzcG9kV3R2ZGtCMWMzTmpMbkoxWENJK2MzcG9kV3R2ZGtCMWMzTmpMbkoxUEZ3dllUNDhienB3UGp4Y0wyODZjRDQ4WEM5emNHRnVQanhjTDNBK1hISmNianh3SUdOc1lYTnpQVndpVFhOdlRtOXliV0ZzWENJK1BITndZVzRnYkdGdVp6MWNJa1ZPTFZWVFhDSWdjM1I1YkdVOVhDSnRjMjh0Wm1GeVpXRnpkQzFzWVc1bmRXRm5aVHBTVlZ3aVBqeGhJR2h5WldZOVhDSm9kSFJ3T2k4dmQzZDNMblZ6YzJNdWNuVmNJajUzZDNjdWRYTnpZeTV5ZFR4Y0wyRStQRzg2Y0Q0OFhDOXZPbkErUEZ3dmMzQmhiajQ4WEM5d1BseHlYRzQ4Y0NCamJHRnpjejFjSWsxemIwNXZjbTFoYkZ3aVBqeHZPbkErSm01aWMzQTdQRnd2Ynpwd1BqeGNMM0ErWEhKY2JqeGNMMlJwZGo1Y2NseHVQSEErUEhOd1lXNGdjM1I1YkdVOVhDSm1iMjUwTFhOcGVtVTZPUzR3Y0hRN1ptOXVkQzFtWVcxcGJIazZKbkYxYjNRN1FYSnBZV3dtY1hWdmREc3NjMkZ1Y3kxelpYSnBaanRqYjJ4dmNqb2pNMEUzTlVNMFhDSSswS1BRc3RDdzBMYlFzTkMxMEx6Umk5QzFJTkM2MEw3UXU5QzcwTFhRczlDNElOQzRJTkMvMExEUmdOR0MwTDNRdGRHQTBZc3NQRzg2Y0Q0OFhDOXZPbkErUEZ3dmMzQmhiajQ4WEM5d1BseHlYRzQ4Y0Q0OGMzQmhiaUJ6ZEhsc1pUMWNJbVp2Ym5RdGMybDZaVG81TGpCd2REdG1iMjUwTFdaaGJXbHNlVG9tY1hWdmREdEJjbWxoYkNaeGRXOTBPeXh6WVc1ekxYTmxjbWxtTzJOdmJHOXlPaU16UVRjMVF6UmNJajdRbmRDdzBZalFzQ0RRbXRDKzBMelF2OUN3MEwzUXVOR1BJTkMvMFlEUXVOQzAwTFhSZ05DMjBMalFzdEN3MExYUmd0R0IwWThnMFkzUmd0QzQwWWZRdGRHQjBMclF1TkdGSU5DLzBZRFF1TkM5MFliUXVOQy8wTDdRc2lEUXN0QzEwTFRRdGRDOTBMalJqeURRc2RDNDBMZlF2ZEMxMFlIUXNDRFF1Q0RRdE5DMTBMdlFzTkMxMFlJZzBMTFJnZEMxSU5DMDBMdlJqeURSZ3RDKzBMUFF2aXdnMFlmUmd0QyswTEhSaXlEUXN0QzMwTERRdU5DODBMN1F2dEdDMEwzUXZ0R0kwTFhRdmRDNDBZOGcwWUVnMEwzUXNOR0kwTGpRdk5DNElOQy8wTERSZ05HQzBMM1F0ZEdBMExEUXZOQzRJTkdCMFlMUmdOQyswTGpRdTlDNDBZSFJqQ0RRdmRDd0lOQy8wWURRdU5DOTBZYlF1TkMvMExEUmhTRFF2dEdDMExyUmdOR0wwWUxRdnRHQjBZTFF1Q0RRdUNEUXY5R0EwTDdRdDlHQTBMRFJoOUM5MEw3UmdkR0MwTGd1WEhKY2JpRFFuOUMrMFkzUmd0QyswTHpSZ3lEUXY5R0EwTDdSZ2RDNDBMd2cwSkxRc05HQklOR0IwTDdRdnRDeDBZblFzTkdDMFl3ZzBMM1FzTkM4SU5DKzBMSFF2aURRc3RHQjBMWFJoU0RRdmRDMTBMUFFzTkdDMExqUXN0QzkwWXZSaFNEUmhOQ3cwTHJSZ3RDdzBZVWcwTExRdmlEUXN0QzMwTERRdU5DODBMN1F2dEdDMEwzUXZ0R0kwTFhRdmRDNDBZL1JoU0RSZ1NEUXZkQ3cwWWpRdGRDNUlOQzYwTDdRdk5DLzBMRFF2ZEM0MExYUXVTRFF2OUMrSU5DdzBMVFJnTkMxMFlIUmcxeHlYRzQ4WVNCb2NtVm1QVndpYldGcGJIUnZPbVJ2ZG1WeWFXVkFjMk50TG5KMVhDSStQSE53WVc0Z2MzUjViR1U5WENKamIyeHZjam9qTTBFM05VTTBYQ0krWkc5MlpYSnBaVUJ6WTIwdWNuVThYQzl6Y0dGdVBqeGNMMkUrTGlEUWt0R0IwWThnMExqUXZkR0UwTDdSZ05DODBMRFJodEM0MFk4ZzBML1F2dEdCMFlMUmc5Qy8wTERRdGRHQ0lOQ3lJTkM5MExYUXQ5Q3cwTExRdU5HQjBMalF2TkdEMFk0ZzBZSFF1OUdEMExiUXNkR0RJTkN5MEwzUmc5R0MwWURRdGRDOTBMM1F0ZEN6MEw0ZzBMRFJnOUMwMExqUmd0Q3dManh2T25BK1BGd3ZienB3UGp4Y0wzTndZVzQrUEZ3dmNENWNjbHh1UEhBK1BITndZVzRnYzNSNWJHVTlYQ0ptYjI1MExYTnBlbVU2T1M0d2NIUTdabTl1ZEMxbVlXMXBiSGs2Sm5GMWIzUTdRWEpwWVd3bWNYVnZkRHNzYzJGdWN5MXpaWEpwWmp0amIyeHZjam9qTTBFM05VTTBYQ0krMEovUmdOQzEwWUxRdGRDOTBMZlF1TkM0SU5DLzBMNGcwTHJRc05HSDBMWFJnZEdDMExMUmd5RFF2dEN4MFlIUXU5R0QwTGJRdU5DeTBMRFF2ZEM0MFk4ZzBMalF1OUM0SU5HQzBMN1FzdEN3MFlEUXNDRFF2OUdBMExqUXZkQzQwTHpRc05HTzBZTFJnZEdQSU5DOTBMQWcwWUxRdGRDNzBMWFJoTkMrMEwwZzBMUFF2dEdBMFkvUmg5QzEwTGtnMEx2UXVOQzkwTGpRdUZ4eVhHNDhkVDQ0TFRnd01DMDNNREF3TFRFeU16eGNMM1UrTGlEUWw5Q3kwTDdRdmRDNjBMZ2cwTC9RdmlEUW9OQyswWUhSZ2RDNDBMZ2cwTEhRdGRHQjBML1F1OUN3MFlMUXZkQytQRzg2Y0Q0OFhDOXZPbkErUEZ3dmMzQmhiajQ4WEM5d1BseHlYRzQ4WEM5a2FYWStYSEpjYmp4Y0wyUnBkajVjY2x4dVBGd3ZZbTlrZVQ1Y2NseHVQRnd2YUhSdGJENWNjbHh1SW4wPQ=="
    email_content = text_from_hash(hash)
    print("Начало обработки...")
    start_time = time.time()
    results = selector.process_email(email_content)
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Время обработки письма: {elapsed_time:.2f} секунд")

    print("Итоговые результаты подбора материалов:")
    for pos, res in results.items():
        print(f"Позиция: {pos} -> Материалы: {res}")